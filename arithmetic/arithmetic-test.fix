module CPLib.Arithmetic.Test;

import CPLib.Arithmetic;
import BoolArray::BoolArray::@;
import Random;

test : IO ();
test = (
    test_pmod;;
    test_mod_arithmetic;;
    test_isqrt;;
    test_gcd;;
    test_ext_gcd;;
    test_pow_mod;;
    test_inv_mod;;
    test_prime_table;;
    test_prime_list;;
    test_miller_rabin_u64;;
    test_miller_rabin_u32;;
    test_inv_gcd;;
    test_crt;;
    test_calc_primitive_root;;

    pure()
);

test_pmod : IO ();
test_pmod = (
    assert_eq(|_|"pmod 1", 12.pmod(5), 2);;
    assert_eq(|_|"pmod 4", -12.pmod(5), 3);;
    assert_eq(|_|"pmod 5", 0.pmod(5), 0);;
    assert_eq(|_|"pmod 6", I64::maximum.pmod(I64::maximum), 0);;
    assert_eq(|_|"pmod 7", I64::minimum.pmod(I64::maximum), I64::maximum-1);;

    pure()
);

test_mod_arithmetic : IO ();
test_mod_arithmetic = (
    assert_eq(|_|"add_mod 1", add_mod(I64::maximum, I64::maximum, I64::maximum), 0);;
    assert_eq(|_|"add_mod 2", add_mod(I64::minimum, I64::minimum, I64::maximum), I64::maximum-2);;
    assert_eq(|_|"add_mod 3", add_mod(I64::minimum, I64::maximum, I64::maximum), I64::maximum-1);;

    assert_eq(|_|"sub_mod 1", sub_mod(I64::maximum, I64::maximum, I64::maximum), 0);;
    assert_eq(|_|"sub_mod 2", sub_mod(I64::minimum, I64::minimum, I64::maximum), 0);;
    assert_eq(|_|"sub_mod 3", sub_mod(I64::minimum, I64::maximum, I64::maximum), I64::maximum-1);;
    assert_eq(|_|"sub_mod 4", sub_mod(I64::maximum, I64::minimum, I64::maximum), 1);;
    assert_eq(|_|"sub_mod 5", sub_mod(I64::maximum, 0, I64::maximum), 0);;
    assert_eq(|_|"sub_mod 6", sub_mod(0, I64::maximum, I64::maximum), 0);;
    assert_eq(|_|"sub_mod 7", sub_mod(0, I64::minimum, I64::maximum), 1);;
    assert_eq(|_|"sub_mod 8", sub_mod(I64::minimum, 0, I64::maximum), I64::maximum-1);;

    assert_eq(|_|"mul_mod 1", mul_mod(I64::maximum, I64::maximum, I64::maximum), 0);;
    assert_eq(|_|"mul_mod 2", mul_mod(I64::minimum, I64::minimum, I64::maximum), 1);;
    assert_eq(|_|"mul_mod 3", mul_mod(I64::minimum, I64::maximum, I64::maximum), 0);;

    pure()
);

test_isqrt : IO ();
test_isqrt = (
    let isqrt_bs : U64 -> U64 = |x| (
        loop((0_U64, U64::maximum), |(l, r)|
            // l*l <= x < r*r
            if r - l <= 1_U64 { break $ l };
            let m = l + (r - l) / 2_U64;
            continue $ if m <= x / m {
                (m, r)
            } else {
                (l, m)
            }
        )
    );

    assert_eq(|_|"isqrt 1", isqrt(0_U64), 0_U64);;
    assert_eq(|_|"isqrt 2", isqrt(1_U64), 1_U64);;
    assert_eq(|_|"isqrt 2", isqrt(2_U64), 1_U64);;
    assert_eq(|_|"isqrt 3", isqrt(3_U64), 1_U64);;
    assert_eq(|_|"isqrt 4", isqrt(4_U64), 2_U64);;
    assert_eq(|_|"isqrt 5", isqrt(5_U64), 2_U64);;
    assert_eq(|_|"isqrt 5", isqrt(2000000_U64), 1414_U64);;
    assert_eq(|_|"isqrt 5", isqrt(U64::maximum), (1.shift_left(32) - 1).to_U64);;

    pure()
);

test_gcd : IO ();
test_gcd = (
    assert_eq(|_|"gcd 1", calc_gcd(12, 15), 3);;
    assert_eq(|_|"gcd 1", calc_gcd(-12, 15), 3);;
    assert_eq(|_|"gcd 2", calc_gcd(12, -15), 3);;
    assert_eq(|_|"gcd 3", calc_gcd(-12, -15), 3);;
    assert_eq(|_|"gcd 4", calc_gcd(0, 15), 15);;
    assert_eq(|_|"gcd 5", calc_gcd(15, 0), 15);;
    assert_eq(|_|"gcd 6", calc_gcd(0, 0), 0);;
    assert_eq(|_|"gcd 7", calc_gcd(17, 19), 1);;
    assert_eq(|_|"gcd 8", calc_gcd(17, 17), 17);;

    pure()
);

test_ext_gcd : IO ();
test_ext_gcd = (
    let (d, (x, y)) = ext_gcd(12, 15);
    assert_eq(|_|"ext_gcd 1a", d, 3);;
    assert_eq(|_|"ext_gcd 1b", x * 12 + y * 15, d);;

    let (d, (x, y)) = ext_gcd(-12, 15);
    assert_eq(|_|"ext_gcd 2a", d, 3);;
    assert_eq(|_|"ext_gcd 2b", x * -12 + y * 15, d);; 

    let (d, (x, y)) = ext_gcd(12, -15);
    assert_eq(|_|"ext_gcd 3a", d, 3);;
    assert_eq(|_|"ext_gcd 3b", x * 12 + y * -15, d);;

    let (d, (x, y)) = ext_gcd(-12, -15);
    assert_eq(|_|"ext_gcd 4a", d, 3);;
    assert_eq(|_|"ext_gcd 4b", x * -12 + y * -15, d);;

    let (d, (x, y)) = ext_gcd(0, 15);
    assert_eq(|_|"ext_gcd 5a", d, 15);;
    assert_eq(|_|"ext_gcd 5b", x * 0 + y * 15, d);;

    let (d, (x, y)) = ext_gcd(15, 0);
    assert_eq(|_|"ext_gcd 6a", d, 15);;
    assert_eq(|_|"ext_gcd 6b", x * 15 + y * 0, d);;

    let (d, (x, y)) = ext_gcd(0, 0);
    assert_eq(|_|"ext_gcd 7a", d, 0);;
    assert_eq(|_|"ext_gcd 7b", x * 0 + y * 0, d);;

    let (d, (x, y)) = ext_gcd(17, 19);
    assert_eq(|_|"ext_gcd 8a", d, 1);;
    assert_eq(|_|"ext_gcd 8b", x * 17 + y * 19, d);;

    let (d, (x, y)) = ext_gcd(17, 17);
    assert_eq(|_|"ext_gcd 9a", d, 17);;
    assert_eq(|_|"ext_gcd 9b", x * 17 + y * 17, d);;

    pure()
);

test_pow_mod : IO ();
test_pow_mod = (
    // 基本的なケース
    assert_eq(|_|"pow_mod 1 (5^2 mod 3)", 5.pow_mod(2, 3), 1);; // 5^2 = 25, 25 mod 3 = 1
    assert_eq(|_|"pow_mod 2 (5^3 mod 4)", 5.pow_mod(3, 4), 1);; // 5^3 = 125, 125 mod 4 = 1
    assert_eq(|_|"pow_mod 3 (2^10 mod 7)", 2.pow_mod(10, 7), 2);; // 2^10 = 1024, 1024 mod 7 = 2
    assert_eq(|_|"pow_mod 4 (0^5 mod 10)", 0.pow_mod(5, 10), 0);; // 0^5 = 0, 0 mod 10 = 0
    assert_eq(|_|"pow_mod 5 (any^0 mod any)", 123.pow_mod(0, 456), 1);; // 指数0の場合、常に1

    // 負の底のテスト (pmodの振る舞いによる)
    assert_eq(|_|"pow_mod 6 (-5^2 mod 3)", (-5).pow_mod(2, 3), 1);; // (-5)^2 = 25, 25 mod 3 = 1
    assert_eq(|_|"pow_mod 7 (-2^3 mod 5)", (-2).pow_mod(3, 5), 2);; // (-2)^3 = -8, -8 mod 5 = 2

    // 法が1の場合のテスト
    assert_eq(|_|"pow_mod 8 (any^any mod 1)", 7.pow_mod(100, 1), 0);; // mod 1 は常に0

    // オーバーフローに着目したテスト
    let max = I32::maximum.to_I64;
    assert_eq(|_|"pow_mod 9 (large x, e, m)", (max - 1).pow_mod(2, max), (max - 1) * (max - 1) % max);;
    assert_eq(|_|"pow_mod 10 (large x, e, small m)", max.pow_mod(10, 2), 1);;
    assert_eq(|_|"pow_mod 11 (large x, large m)", (max / 2).pow_mod(3, max / 3), (((max / 2) * (max / 2)) % (max / 3) * (max / 2)) % (max / 3));;

    // 特殊なケース
    assert_eq(|_|"pow_mod 12 (0^0 mod any)", 0.pow_mod(0, 5), 1);;

    pure()
);

test_inv_mod : IO ();
test_inv_mod = (
    let m = 17;
    range(-30, 30).filter(|x| x.pmod(m) != 0).fold_m((), |a, _|
        let x = a.inv_mod(m);
        let ax = (a * x).pmod(m);
        assert_eq(|_|"test_inv_mod ax mod m - 1, x = " + x.to_string, ax, 1);;
        assert(|_|"test_inv_mod 0 <= x < m, x = " + x.to_string, 0 <= x && x < m);;
        pure()
    );;
    pure()
);

test_prime_table : IO ();
test_prime_table = (
    let prime_table = create_prime_table(20);
    assert_eq(|_|"test_prime_table 0", prime_table.@(0), false);;
    assert_eq(|_|"test_prime_table 1", prime_table.@(1), false);;
    assert_eq(|_|"test_prime_table 2", prime_table.@(2), true);;
    assert_eq(|_|"test_prime_table 3", prime_table.@(3), true);;
    assert_eq(|_|"test_prime_table 4", prime_table.@(4), false);;
    assert_eq(|_|"test_prime_table 5", prime_table.@(5), true);;
    assert_eq(|_|"test_prime_table 6", prime_table.@(6), false);;
    assert_eq(|_|"test_prime_table 7", prime_table.@(7), true);;
    assert_eq(|_|"test_prime_table 8", prime_table.@(8), false);;
    assert_eq(|_|"test_prime_table 9", prime_table.@(9), false);;
    assert_eq(|_|"test_prime_table 10", prime_table.@(10), false);;
    assert_eq(|_|"test_prime_table 11", prime_table.@(11), true);;
    assert_eq(|_|"test_prime_table 12", prime_table.@(12), false);;
    assert_eq(|_|"test_prime_table 13", prime_table.@(13), true);;
    assert_eq(|_|"test_prime_table 14", prime_table.@(14), false);;
    assert_eq(|_|"test_prime_table 15", prime_table.@(15), false);;
    assert_eq(|_|"test_prime_table 16", prime_table.@(16), false);;
    assert_eq(|_|"test_prime_table 17", prime_table.@(17), true);;
    assert_eq(|_|"test_prime_table 18", prime_table.@(18), false);;
    assert_eq(|_|"test_prime_table 19", prime_table.@(19), true);;
    pure()
);

test_prime_list : IO ();
test_prime_list = (
    assert_eq(|_|"test_prime_list 1", create_prime_list(20).map(to_I64), [2, 3, 5, 7, 11, 13, 17, 19]);;
    let (res, time) = consumed_time_while_lazy(|_| create_prime_list(1e8));
    assert_eq(|_|"test_prime_list 2", res.get_size, 5761455);;
    println $ "create_prime_list(1e8) took " + time.to_string + " s";;
    pure()
);

test_miller_rabin_u64 : IO ();
test_miller_rabin_u64 = (
    let _N = 1e5;
    let prime_table = create_prime_table(_N);
    range(0, _N).fold_m((), |n, _|
        assert_eq(|_|"check_is_prime_u64: " + n.to_string, prime_table.@(n), is_prime(n.to_U64))
    );;
    assert_eq(|_|"2^61-1 is prime", is_prime(1_U64.shift_left(61_U64) - 1_U64), true);;
    assert_eq(|_|"2^59-1 is not prime", is_prime(1_U64.shift_left(59_U64) - 1_U64), false);;
    pure()
);

test_miller_rabin_u32 : IO ();
test_miller_rabin_u32 = (
    let _N = 1e5;
    let prime_table = create_prime_table(_N);
    range(0, _N).fold_m((), |n, _|
        assert_eq(|_|"check_is_prime_u32: " + n.to_string, prime_table.@(n), is_prime_32(n.to_U32))
    );;
    assert_eq(|_|"2^31-1 is prime", is_prime_32(1_U32.shift_left(31_U32) - 1_U32), true);;
    assert_eq(|_|"2^29-1 is not prime", is_prime_32(1_U32.shift_left(29_U32) - 1_U32), false);;
    pure()
);

test_inv_gcd : IO ();
test_inv_gcd = (
    let _N = 1e3;
    let rng = Random::init_by_seed(0_U64);
    range(0, _N).fold_m(rng, |_, rng|
        let (rng, a) = rng.generate_U64;
        let a = a.to_I64;
        let (rng, b) = rng.generate_I64_nonneg;
        let b = if b == I64::maximum { 1 } else { b + 1 };        // b >= 1 にする
        let (g, x) = _inv_gcd(a, b);
        assert_eq(|_|"[test_inv_gcd] g = gcd(a, b)", g, calc_gcd(a, b));;
        assert_eq(|_|"[test_inv_gcd] xa = g (mod b)", mul_mod(x, a, b), g.pmod(b));;
        assert(|_|"[test_inv_gcd] 0 <= x < b/g", 0 <= x && x < b / g);;
        rng.pure
    ).forget;;
    pure()
);

test_crt : IO ();
test_crt = (
    let _N = 1e3;
    let rng = Random::init_by_seed(0_U64);
    range(0, _N).fold_m(rng, |_, rng|
        // 解がある場合のみチェック
        let (rng, m0) = rng.generate_I64_nonneg;
        let m0 = max(1, m0 % (I32::maximum.to_I64 - 1));
        let (rng, m1) = rng.generate_I64_nonneg;
        let m1 = max(1, m1 % (I32::maximum.to_I64 - 1));
        let (rng, x) = rng.generate_U64;
        let x = x.to_I64;
        let r0 = x.pmod(m0);
        let r1 = x.pmod(m1);
        // "{} {} {} {}".populate([r0, r1, m0, m1].map(to_string)).println;;
        let (y, z) = lift_crt([r0, r1], [m0, m1]);
        let lcm = m0 / calc_gcd(m0, m1) * m1;
        assert_eq(|_|"[test_crt] z is lcm", z, lcm);;
        assert_eq(|_|"[test_crt] y mod m0", y.pmod(m0), r0);;
        assert_eq(|_|"[test_crt] y mod m1", y.pmod(m1), r1);;
        rng.pure
    ).forget;;
    pure()
);

test_calc_primitive_root : IO ();
test_calc_primitive_root = (
    // TODO: add (999999999999999989, 3)
    [(2, 1), (3, 2), (5, 2), (7, 3), (11, 2), (13, 2), (17, 3), (19, 2), (1e9 + 7, 5), (998244353, 3)].to_iter.map(|(p, ans)|
        let r = calc_primitive_root(p);
        assert_eq(|_|"[test_calc_primitive_root] {}".populate([p.to_string]), r, ans)
    ).collect_m;;
    pure()

);
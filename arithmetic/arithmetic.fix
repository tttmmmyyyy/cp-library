module CPLib.Arithmetic;

import BoolArray;

// `x`を`m`で割った余りを非負で返す
//
// C言語の%演算子とは異なり、負の数に対しても正の余りを返す
//
// # Parameters
// - `m`: 除数 > 0
// - `x`: 被除数
pmod : I64 -> I64 -> I64;
pmod = |m, x| (
    let r = x % m;
    if r < 0 { r + m } else { r }
);

// `x + y`を`m`で割った余りを（非負で）返す
//
// # Parameters
// - `x`: 整数
// - `y`: 整数
// - `m`: 除数 != 0
add_mod : I64 -> I64 -> I64 -> I64;
add_mod = |x, y, m| (
    let m = m.abs.to_U64;
    FFI_CALL[I64 cp_lib_add_mod_signed(I64, I64, U64), x, y, m]
);

// `x - y`を`m`で割った余りを（非負で）返す
// 
// # Parameters
// - `x`: 整数
// - `y`: 整数
// - `m`: 除数 != 0
sub_mod : I64 -> I64 -> I64 -> I64;
sub_mod = |x, y, m| (
    let m = m.abs.to_U64;
    FFI_CALL[I64 cp_lib_sub_mod_signed(I64, I64, U64), x, y, m]
);

// `x * y`を`m`で割った余りを（非負で）返す
//
// # Parameters
// - `x`: 整数
// - `y`: 整数
// - `m`: 除数 != 0
mul_mod : I64 -> I64 -> I64 -> I64;
mul_mod = |x, y, m| (
    let m = m.abs.to_U64;
    FFI_CALL[I64 cp_lib_mul_mod_signed(I64, I64, U64), x, y, m]
);

// 64ビット整数の平方根の整数部分を計算する
//
// # Parameters
// - `x`: 64ビット整数
isqrt : U64 -> U64;
isqrt = |s| (
    if s <= 1_U64 { s };
    let x0 = s / 2_U64;
    let x1 = (x0 + s / x0) / 2_U64;
    loop((x0, x1), |(x0, x1)| 
        if x1 >= x0 { break $ x0 };
        let x0 = x1;
        let x1 = (x0 + s / x0) / 2_U64;
        continue $ (x0, x1)
    )
);

// 2つの整数の最大公約数（非負整数）を計算する
// 
// # Parameters
// - `a`: 整数
// - `b`: 整数
calc_gcd : I64 -> I64 -> I64;
calc_gcd = |a, b| (
    if b == 0 { a.abs };
    calc_gcd(b, a % b)
);

// 拡張ユークリッドの互除法
// 
// 2つの整数 `a`, `b` に対して、その最大公約数 `d >= 0` および、`ax + by = d` を満たす整数 `x`, `y` を求める
//
// # Returns 
// `(d, (x, y))`
// 
// # Parameters
// - `a`: 整数
// - `b`: 整数
ext_gcd : I64 -> I64 -> (I64, (I64, I64));
ext_gcd = |a, b| (
    if b == 0 { 
        if a >= 0 { (a, (1, 0)) } else { (-a, (-1, 0)) }
    };
    let (d, (x1, y1)) = ext_gcd(b, a % b);
    (d, (y1, x1 - (a / b) * y1))
);

// `x^e`を`n`で割った余りを計算する
//
// # Parameters
// - `x`: 底
// - `e`: 指数 >= 0
// - `m`: 法 > 0
pow_mod : I64 -> I64 -> I64 -> I64;
pow_mod = |e, m, x| (
    let e = e.to_U64;
    let m = m.abs;
    let x = x.pmod(m).to_U64;
    x.pow_mod_u(e, m.to_U64).to_I64
);

// `x^e`を`n`で割った余りを計算する（unsigned版）
//
// # Parameters
// - `x`: 底 >= 0
// - `e`: 指数 >= 0
// - `m`: 法 > 0
pow_mod_u : U64 -> U64 -> U64 -> U64;
pow_mod_u = |e, m, x| (
    if e == 0_U64 { 1_U64 };
    if e % 2_U64 == 0_U64 {
        let half = x.pow_mod_u(e / 2_U64, m);
        let hh = FFI_CALL[U64 cp_lib_mul_mod(U64, U64, U64), half, half, m];
        hh
    } else {
        let half = x.pow_mod_u((e - 1_U64) / 2_U64, m);
        let hh = FFI_CALL[U64 cp_lib_mul_mod(U64, U64, U64), half, half, m];
        let xhh = FFI_CALL[U64 cp_lib_mul_mod(U64, U64, U64), x, hh, m];
        xhh
    }
);

// `ax = 1 mod m`なる`x`のうち、`0 <= x < |m|`を満たすものを返す
//
// 制約：gcd(a, m) = 1
//
// # Parameters
// - `a`: 整数
// - `m`: 法 > 0
inv_mod : I64 -> I64 -> I64;
inv_mod = |m, a| (
    let m = m.abs;
    let (d, (inv_x, _)) = ext_gcd(a.pmod(m), m);
    if d != 1 {
        undefined("[inv_mod] `a` is not coprime to `m`!")
    };
    inv_x.pmod(m)
);

// [0, n)の範囲での素数テーブルを作成する
//
// 配列（`BoolArray`）`table`は素数テーブルであり、`table.@(n)`が`true`の場合に`n`が素数であることを意味する。
// 
// 注意：戻り値の要素に`@(n)`でアクセスするには`import BoolArray;`が必要です。
//
// # Parameters
// - `n` : 素数テーブルの上限（exclusive）
create_prime_table : I64 -> BoolArray;
create_prime_table = |size| (
    let table = BoolArray::make(size).fill_true;
    let size = table.get_size;
    let table = table.set(0, false).set(1, false);
    let table = Iterator::range(2, size).loop_iter(table, |n, table|
        if n > (size - 1) / n { break $ table };
        if !table.@(n) { continue $ table };
        let table = Iterator::range_step(2 * n, size, n).fold(table, |m, table| table.set(m, false));
        continue $ table
    );
    table
);

// [0, n)の範囲での素数リストを作成する
//
// # Parameters
// - `n` : 素数リストの上限（exclusive）
create_prime_list : I64 -> Array U32;
create_prime_list = |n| (
    let table = create_prime_table(n);
    let count = Iterator::range(0, n).fold(0, |i, cnt| if table.@(i) { cnt + 1 } else { cnt });
    let list = Array::empty(count);
    let list = Iterator::range(0, n).fold(list, |p, list|
        if table.@(p) { list.push_back(p.to_U32) } else { list }
    );
    list
);

// n-1 = 2^s * d (d: 奇数)に対し、2 <= a <= n-2 を使ってnが合成数かどうかを調べる。
// 
// a^d = 1 (mod n) または、a^(2^r * d) = -1 (mod n) (0 <= r < s) のいずれかが成り立つならば、nは素数である可能性があるので、falseを返す。
// そうでない場合は、nは合成数であるので、trueを返す。
// 
// # Parameters
// - `n`: 調べる数
// - `a`: 2 <= a <= n-2 の範囲の整数
// - `d`: n-1 = 2^s * d の 奇数d
// - `s`: n-1 = 2^s * d の 2の指数部分
_check_composite_miller_rabin : U64 -> U64 -> U64 -> I64 -> Bool;
_check_composite_miller_rabin = |n, a, d, s| (
    let x = a.pow_mod_u(d, n); // a^d
    if x == 1_U64 || x == n - 1_U64 { false }; // a^d = 1,  or  a^(2^r * d) = -1 for r = 0
    range(1, s).loop_iter_s(x, |_r, x|
        let x = x.pow_mod_u(2_U64, n); // a^(2^r * d)
        if x == n - 1_U64 { break $ () };
        continue $ x
    ).is_continue
);

// Miller-Rabin 素数判定法（64bit版）
// 
// https://cp-algorithms.com/algebra/primality_tests.html#deterministic-version
// 
// # Parameters
// - `n`: 調べる数
is_prime : U64 -> Bool;
is_prime = |n| (
    if n < 2_U64 { false };
    let (s, d) = loop((0, n-1_U64), |(s, d)|
        if d % 2_U64 == 0_U64 {
            continue $ (s + 1, d / 2_U64)
        } else {
            break $ (s, d)
        }
    );
    match [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37].to_iter.loop_iter_s((), |a, _|
        if n == a.to_U64 { break $ true };
        if _check_composite_miller_rabin(n, a.to_U64, d, s) { break $ false };
        continue $ ()
    ) {
        break(r) => r,
        continue(_) => true
    }
);

// Miller-Rabin 素数判定法（32bit版）
// 
// https://cp-algorithms.com/algebra/primality_tests.html#deterministic-version
// 
// # Parameters
// - `n`: 調べる数
is_prime_32 : U32 -> Bool;
is_prime_32 = |n| (
    if n < 2_U32 { false };
    let (s, d) = loop((0, n-1_U32), |(s, d)|
        if d % 2_U32 == 0_U32 {
            continue $ (s + 1, d / 2_U32)
        } else {
            break $ (s, d)
        }
    );
    match [2, 3, 5, 7].to_iter.loop_iter_s((), |a, _|
        if n == a.to_U32 { break $ true };
        if _check_composite_miller_rabin(n.to_U64, a.to_U64, d.to_U64, s) { break $ false };
        continue $ ()
    ) {
        break(r) => r,
        continue(_) => true
    }
);

// @param b `1 <= b`
// @return pair(g, x) s.t. g = gcd(a, b), xa = g (mod b), 0 <= x < b/g
// 
// https://github.com/atcoder/ac-library/blob/master/atcoder/internal_math.hpp#L107
_inv_gcd : I64 -> I64 -> (I64, I64);
_inv_gcd = |a, b| (
    let a = a.pmod(b);
    if a == 0 { (b, 0) };

    let s = b; let t = a;
    let m0 = 0; let m1 = 1;

    let (s, m0) = loop((s, t, m0, m1), |(s, t, m0, m1)|
        if t == 0 { break $ (s, m0) };
        let u = s / t;
        let s = s - t * u;
        let m0 = m0 - m1 * u;

        let tmp = s;
        let s = t;
        let t = tmp;
        let tmp = m0;
        let m0 = m1;
        let m1 = tmp;
        continue $ (s, t, m0, m1)
    );

    let m0 = if m0 < 0 { m0 + b / s } else { m0 };
    (s, m0)
);

// 連立合同方程式 P: x = r(i) (mod m(i)) を解きます。
// 
// 解が存在するときは P <=> x = y (mod z), z = lcm(m(i)) となるような (y, z) を返します。
// 
// 解が存在しない場合は、`(0, 0)`を返します。
// 
// 制約や計算量オーダーは https://atcoder.github.io/ac-library/master/document_ja/math.html の`crt`と同様です。
// 
// # Parameters
// - `rs`: r(i)の配列
// - `ms`: m(i) >= 1の配列。r(i)と同じ長さ。
lift_crt : Array I64 -> Array I64 -> (I64, I64);
lift_crt = |r, m| (
    // if r.get_size != m.get_size { undefined("[lift_crt] `rs` and `ms` must have the same size") };
    let n = r.get_size;
    let r0 = 0; let m0 = 1;

    range(0, n).loop_iter((r0, m0), |i, (r0, m0)|
        // if m.@(i) <= 0 { undefined("[lift_crt] `ms.@(i)` must be positive") };
        let r1 = r.@(i).pmod(m.@(i));
        let m1 = m.@(i);
        let (r0, r1, m0, m1) = if m0 < m1 {
            (r1, r0, m1, m0)
        } else {
            (r0, r1, m0, m1)
        };
        if m0 % m1 == 0 {
            if r0 % m1 != r1 {
                break $ (0, 0)
            };
            continue $ (r0, m0)
        };
        let (g, im) = _inv_gcd(m0, m1);
        let u1 = m1 / g;
        if (r1 - r0) % g != 0 {
            break $ (0, 0)
        };
        let x = (r1 - r0) / g % u1 * im % u1;
        let r0 = r0 + x * m0;
        let m0 = m0 * u1;
        let r0 = r0 + if r0 < 0 { m0 } else { 0 };
        continue $ (r0, m0)
    )
);

// 素数pの原始根r（1 <= r < p）を一つ求める。
// 
// # Parameters
// - `p`: 素数
_calc_primitive_root : I64 -> I64;
_calc_primitive_root = |p| (
    // 各 1 <= g <= p-1 ごとに、g が原子根であるかを調べる。
    // 全ての φ(p) = p-1 の素因子qに対し g^(φ(p) / q) != 1 であるならば、gは原子根である。

    let factors = loop((2, p-1, []), |(q, n, factors)|
        if n == 1 { break $ factors };
        if n % q != 0 { continue $ (q + 1, n, factors) };
        let factors = factors.push_back(q);
        let n = loop(n, |n|
            if n % q != 0 { break $ n };
            continue $ n / q
        );
        continue $ (q + 1, n, factors)
    );

    range(1, p).filter_map(|g|
        let ok = factors.to_iter.check_all(|q|
            let e = (p - 1) / q;
            g.pow_mod(e, p) != 1
        );
        if ok { some(g) } else { none() }
    ).get_first.as_some
);

// 素数pの原始根r（1 <= r < p）を一つ求める。
// 
// https://cp-algorithms.com/algebra/primitive-root.html#algorithm-for-finding-a-primitive-root
// 
// 注意：現状、この関数はp-1の素因数分解を素朴なO(sqrt(p))の方法で行います。
// 
// # Parameters
// - `p`: 素数
calc_primitive_root : I64 -> I64;
calc_primitive_root = |p| (
    if p == 1e9 + 7 { 5 } else if p == 998244353 { 3 };
    p._calc_primitive_root
);
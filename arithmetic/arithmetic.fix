module CPLib.Arithmetic;

import BoolArray;

// `x`を`m`で割った余りを非負で返す
//
// C言語の%演算子とは異なり、負の数に対しても正の余りを返す
//
// # Parameters
// - `m`: 除数
// - `x`: 被除数
pmod : I64 -> I64 -> I64;
pmod = |m, x| (
    let m = m.abs;
    let r = x % m;
    if r < 0 { r + m } else { r }
);

// 64ビット整数の平方根の整数部分を計算する
//
// # Parameters
// - `x`: 64ビット整数
isqrt : U64 -> U64;
isqrt = |s| (
    if s <= 1_U64 { s };
    let x0 = s / 2_U64;
    let x1 = (x0 + s / x0) / 2_U64;
    loop((x0, x1), |(x0, x1)| 
        if x1 >= x0 { break $ x0 };
        let x0 = x1;
        let x1 = (x0 + s / x0) / 2_U64;
        continue $ (x0, x1)
    )
);

// 2つの整数の最大公約数（非負整数）を計算する
// 
// # Parameters
// - `a`: 整数
// - `b`: 整数
calc_gcd : I64 -> I64 -> I64;
calc_gcd = |a, b| (
    if b == 0 { a.abs };
    calc_gcd(b, a % b)
);

// 拡張ユークリッドの互除法
// 
// 2つの整数 `a`, `b` に対して、その最大公約数 `d >= 0` および、`ax + by = d` を満たす整数 `x`, `y` を求める
//
// # Returns 
// `(d, (x, y))`
// 
// # Parameters
// - `a`: 整数
// - `b`: 整数
ext_gcd : I64 -> I64 -> (I64, (I64, I64));
ext_gcd = |a, b| (
    if b == 0 { 
        if a >= 0 { (a, (1, 0)) } else { (-a, (-1, 0)) }
    };
    let (d, (x1, y1)) = ext_gcd(b, a % b);
    (d, (y1, x1 - (a / b) * y1))
);

// `x^e`を`n`で割った余りを計算する
//
// # Parameters
// - `x`: 底
// - `e`: 指数 >= 0
// - `m`: 法
pow_mod : I64 -> I64 -> I64 -> I64;
pow_mod = |e, m, x| (
    let e = e.to_U64;
    let m = m.abs;
    let x = x.pmod(m).to_U64;
    x.pow_mod_u(e, m.to_U64).to_I64
);

// `x^e`を`n`で割った余りを計算する（unsigned版）
//
// # Parameters
// - `x`: 底 >= 0
// - `e`: 指数 >= 0
// - `m`: 法 > 0
pow_mod_u : U64 -> U64 -> U64 -> U64;
pow_mod_u = |e, m, x| (
    if e == 0_U64 { 1_U64 };
    if e % 2_U64 == 0_U64 {
        let half = x.pow_mod_u(e / 2_U64, m);
        let hh = FFI_CALL[U64 cp_lib_mul_mod(U64, U64, U64), half, half, m];
        hh
    } else {
        let half = x.pow_mod_u((e - 1_U64) / 2_U64, m);
        let hh = FFI_CALL[U64 cp_lib_mul_mod(U64, U64, U64), half, half, m];
        let xhh = FFI_CALL[U64 cp_lib_mul_mod(U64, U64, U64), x, hh, m];
        xhh
    }
);

// `ax = 1 mod m`なる`x`のうち、`0 <= x < |m|`を満たすものを返す
//
// 制約：gcd(a, m) = 1
//
// # Parameters
// - `a`: 整数
// - `m`: 法
inv_mod : I64 -> I64 -> I64;
inv_mod = |m, a| (
    let m = m.abs;
    let (d, (inv_x, _)) = ext_gcd(a.pmod(m), m);
    if d != 1 {
        undefined("[inv_mod] `a` is not coprime to `m`!")
    };
    inv_x.pmod(m)
);

// [0, n)の範囲での素数テーブルを作成する
//
// 配列（`BoolArray`）`table`は素数テーブルであり、`table.@(n)`が`true`の場合に`n`が素数であることを意味する。
//
// # Parameters
// - `n` : 素数テーブルの上限（exclusive）
create_prime_table : I64 -> BoolArray;
create_prime_table = |size| (
    let table = BoolArray::make(size).fill_true;
    let size = table.get_size;
    let table = table.set(0, false).set(1, false);
    let table = Iterator::range(2, size).loop_iter(table, |n, table|
        if n > (size - 1) / n { break $ table };
        if !table.@(n) { continue $ table };
        let table = Iterator::range_step(2 * n, size, n).fold(table, |m, table| table.set(m, false));
        continue $ table
    );
    table
);

// [0, n)の範囲での素数リストを作成する
//
// # Parameters
// - `n` : 素数リストの上限（exclusive）
create_prime_list : I64 -> Array U32;
create_prime_list = |n| (
    let table = create_prime_table(n);
    let count = Iterator::range(0, n).fold(0, |i, cnt| if table.@(i) { cnt + 1 } else { cnt });
    let list = Array::empty(count);
    let list = Iterator::range(0, n).fold(list, |p, list|
        if table.@(p) { list.push_back(p.to_U32) } else { list }
    );
    list
);
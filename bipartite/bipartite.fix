// 二部グラフを扱うモジュール
module CPLib.Bipartite;

import CPLib.MaxFlow;

// 二部グラフの型
type BipartiteGraph = struct {
    left_size : I64,
    right_size : I64,
    edges : Array (I64, I64),
};

// 二部グラフに対する最大フロー問題のグラフ
type BipartiteGraphFlow = struct {
    graph : BipartiteGraph,
    max_flow : MaxFlowGraph I64,
    // 二部グラフの辺に対応する最大フローグラフの辺の識別子
    edge_ids : Array EdgeId,
};

namespace BipartiteGraph {

    // 二部グラフを作成する
    //
    // # Parameters
    // - `left_size` : 左側の頂点数
    // - `right_size` : 右側の頂点数
    create : I64 -> I64 -> BipartiteGraph;
    create = |left_size, right_size| (
        BipartiteGraph {
            left_size : left_size,
            right_size : right_size,
            edges : []
        }
    );

    // 二部グラフに辺を追加する
    //
    // # Parameters
    // - `graph` : 二部グラフ
    // - `left` : 左側の頂点番号
    // - `right` : 右側の頂点番号
    add_edge : I64 -> I64 -> BipartiteGraph -> BipartiteGraph;
    add_edge = |left, right, graph| (
        if !(0 <= left && left < graph.@left_size) { undefined("Left vertex index out of bounds") };
        if !(0 <= right && right < graph.@right_size) { undefined("Right vertex index out of bounds") };
        graph.mod_edges(push_back((left, right)))
    );

    // 二部グラフに対応する最大フロー問題を作成し、解く
    maximize_flow : BipartiteGraph -> BipartiteGraphFlow;
    maximize_flow = |bg| (
        let n = bg.@left_size + bg.@right_size + 2; // 開始と終了の頂点を含む
        let s = n - 2;
        let t = n - 1;
        let graph = MaxFlowGraph::create(n, s, t, I64::maximum);
        let graph = range(0, bg.@left_size).fold(graph, |i, graph| graph.add_edge(s, i, 1).@0);
        let graph = range(0, bg.@right_size).fold(graph, |i, graph| graph.add_edge(bg.@left_size + i, t, 1).@0);
        let eids = Array::empty(bg.@edges.get_size);
        let (graph, eids) = bg.@edges.to_iter.fold((graph, eids), |(left, right), (graph, eids)|
            let (graph, eid) = graph.add_edge(left, bg.@left_size + right, 1);
            (graph, push_back(eid, eids))
        );
        let (graph, flow) = graph.maximize_flow;
        BipartiteGraphFlow { graph : bg, max_flow : graph, edge_ids : eids }
    );

}

namespace BipartiteGraphFlow {
    // 二部グラフの最大マッチングを取得する
    // 
    // # Returns
    // 第i番目に追加した辺がマッチングに含まれる場合は`true`、含まれない場合は`false`とする配列
    //
    // # Parameters
    // - `max_flow` : 二部グラフの最大フロー
    get_max_matching : BipartiteGraphFlow -> Array Bool;
    get_max_matching = |flow| flow.@edge_ids.map(|eid| flow.@max_flow.get_flow(eid) > 0);

    // 二部グラフの最小点被覆を取得する
    //
    // # Returns
    // 左側の頂点の被覆と右側の頂点の被覆をそれぞれ`Array Bool`として返す。
    // ある頂点が被覆に含まれる場合は`true`、含まれない場合は`false`となる配列が返される。
    //
    // # Parameters
    // - `max_flow` : 二部グラフの最大フロー
    get_min_vertex_cover : BipartiteGraphFlow -> (Array Bool, Array Bool);
    get_min_vertex_cover = |flow| (
        let min_cut = flow.@max_flow.get_min_cut; // 第i番目の頂点に残余グラフで到達可能かどうかの配列
        let left_cover = range(0, flow.@graph.@left_size).map(|i| !min_cut.@(i)).to_array;
        let right_cover = range(0, flow.@graph.@right_size).map(|i| min_cut.@(flow.@graph.@left_size + i)).to_array;
        (left_cover, right_cover)
    );
}
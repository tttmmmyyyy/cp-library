// 二部グラフを扱うモジュール
module CPLib.Bipartite;

import CPLib.Graph::EdgeId;
import CPLib.MaxFlow::{MaxFlowGraph, MaxFlowGraph::{add_edge, add_edge_id, create, get_flow, get_min_cut, maximize_flow}};
import Std::{
    undefined, Array, Bool, I64, Array::{empty, fill, get_size, push_back, set, to_iter, @}, 
    Functor::map, Iterator::{count_up, fold, map, range, to_array, zip}
};

// 二部グラフの型
type BipartiteGraph = struct {
    left_size : I64,
    right_size : I64,
    edges : Array (I64, I64),
};

// 二部グラフに対する最大フロー問題のグラフ
type BipartiteGraphFlow = struct {
    graph : BipartiteGraph,
    max_flow : MaxFlowGraph I64,
    // 二部グラフの辺に対応する最大フローグラフの辺の識別子
    edge_ids : Array EdgeId,
};

namespace BipartiteGraph {

    // 二部グラフを作成する
    //
    // # Parameters
    // - `left_size` : 左側の頂点数
    // - `right_size` : 右側の頂点数
    create : I64 -> I64 -> BipartiteGraph;
    create = |left_size, right_size| (
        BipartiteGraph {
            left_size : left_size,
            right_size : right_size,
            edges : []
        }
    );

    // 二部グラフに辺を追加する
    //
    // # Parameters
    // - `graph` : 二部グラフ
    // - `left` : 左側の頂点番号
    // - `right` : 右側の頂点番号
    add_edge : I64 -> I64 -> BipartiteGraph -> BipartiteGraph;
    add_edge = |left, right, graph| (
        if !(0 <= left && left < graph.@left_size) { undefined("Left vertex index out of bounds") };
        if !(0 <= right && right < graph.@right_size) { undefined("Right vertex index out of bounds") };
        graph.mod_edges(push_back((left, right)))
    );

    // 二部グラフに対応する最大フロー問題を作成し、解く
    maximize_flow : BipartiteGraph -> BipartiteGraphFlow;
    maximize_flow = |bg| (
        let n = bg.@left_size + bg.@right_size + 2; // 開始と終了の頂点を含む
        let s = n - 2;
        let t = n - 1;
        let graph = MaxFlowGraph::create(n, s, t);
        let graph = range(0, bg.@left_size).fold(graph, |i, graph| graph.add_edge(s, i, 1));
        let graph = range(0, bg.@right_size).fold(graph, |i, graph| graph.add_edge(bg.@left_size + i, t, 1));
        let eids = Array::empty(bg.@edges.get_size);
        let (graph, eids) = bg.@edges.to_iter.fold((graph, eids), |(left, right), (graph, eids)|
            let (graph, eid) = graph.add_edge_id(left, bg.@left_size + right, 1);
            (graph, push_back(eid, eids))
        );
        let (graph, flow) = graph.maximize_flow;
        BipartiteGraphFlow { graph : bg, max_flow : graph, edge_ids : eids }
    );

}

namespace BipartiteGraphFlow {
    // 二部グラフの最大マッチングを取得する
    // 
    // # Returns
    // 第i番目に追加した辺がマッチングに含まれる場合は`true`、含まれない場合は`false`とする配列
    //
    // # Parameters
    // - `max_flow` : 二部グラフの最大フロー
    get_max_matching : BipartiteGraphFlow -> Array Bool;
    get_max_matching = |flow| flow.@edge_ids.map(|eid| flow.@max_flow.get_flow(eid) > 0);

    // 二部グラフの最小辺カバーを取得する
    //
    // # 制約
    // 二部グラフに孤立点がない
    //
    // # Returns
    // 第i番目に追加した辺がカバーに含まれる場合は`true`、含まれない場合は`false`とする配列
    //
    // # Parameters
    // - `max_flow` : 二部グラフの最大フロー
    get_min_edge_cover : BipartiteGraphFlow -> Array Bool;
    get_min_edge_cover = |flow| (
        let edge_n = flow.@graph.@edges.get_size;
        let matching = flow.get_max_matching;
        let l_cov = Array::fill(flow.@graph.@left_size, false);
        let r_cov = Array::fill(flow.@graph.@right_size, false);
        // 最大マッチングにカバーされている点を`l_cov`と`r_cov`に反映
        let (l_cov, r_cov) = matching.to_iter.zip(count_up(0)).fold((l_cov, r_cov), |(matched, ei), (l_cov, r_cov)|
            if !matched { (l_cov, r_cov) };
            let (left_v, right_v) = flow.@graph.@edges.@(ei);
            let l_cov = l_cov.set(left_v, true);
            let r_cov = r_cov.set(right_v, true);
            (l_cov, r_cov)
        );
        // 最大マッチングから初めて、まだカバーしていない点をカバーできる辺を追加していく。
        let min_cov = matching;
        let (min_cov, l_cov, r_cov) = range(0, edge_n).fold((min_cov, l_cov, r_cov), |ei, (min_cov, l_cov, r_cov)|
            let (left_v, right_v) = flow.@graph.@edges.@(ei);
            if matching.@(ei) {
                (min_cov, l_cov, r_cov)
            };
            if l_cov.@(left_v) && r_cov.@(right_v) {
                (min_cov, l_cov, r_cov)
            };
            let min_cov = min_cov.set(ei, true);
            let l_cov = l_cov.set(left_v, true);
            let r_cov = r_cov.set(right_v, true);
            (min_cov, l_cov, r_cov)
        );
        min_cov
    );

    // 二部グラフの最小点被覆を取得する
    //
    // # Returns
    // 左側の頂点の被覆と右側の頂点の被覆をそれぞれ`Array Bool`として返す。
    // ある頂点が被覆に含まれる場合は`true`、含まれない場合は`false`となる配列が返される。
    //
    // # Parameters
    // - `max_flow` : 二部グラフの最大フロー
    get_min_vertex_cover : BipartiteGraphFlow -> (Array Bool, Array Bool);
    get_min_vertex_cover = |flow| (
        let min_cut = flow.@max_flow.get_min_cut; // 第i番目の頂点に残余グラフで到達可能かどうかの配列
        let left_cover = range(0, flow.@graph.@left_size).map(|i| !min_cut.@(i)).to_array;
        let right_cover = range(0, flow.@graph.@right_size).map(|i| min_cut.@(flow.@graph.@left_size + i)).to_array;
        (left_cover, right_cover)
    );

    // 二部グラフの最大孤立集合（最大安定集合）を取得する
    // 
    // # Returns
    // 左側の頂点の被覆と右側の頂点の被覆をそれぞれ`Array Bool`として返す。
    // ある頂点が被覆に含まれる場合は`true`、含まれない場合は`false`となる配列が返される。
    // 
    // # Parameters
    // - `max_flow` : 二部グラフの最大フロー
    get_max_indep_set : BipartiteGraphFlow -> (Array Bool, Array Bool);
    get_max_indep_set = |flow| (
        let (left_cover, right_cover) = flow.get_min_vertex_cover;
        let left_stable = left_cover.map(|x| !x);
        let right_stable = right_cover.map(|x| !x);
        (left_stable, right_stable)
    );
}
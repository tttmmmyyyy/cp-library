module CPLib.UnionFind;

import Std::{
    Array, Bool, I64, Array::{fill, get_size, mod, push_back, set, to_iter, @}, 
    Iterator::{filter_map, fold, range, to_array}, Option::{none, some}
};

type UnionFind = struct {
    parent : Array I64,
    rank : Array I64,
    size : Array I64,
};

// UnionFind木を作成する
// 
// `0`から`size - 1`までの`size`個の要素を持つUnionFind木を作成する
// 
// # Parameters
// - `size` : UnionFind木のサイズ
create : I64 -> UnionFind;
create = |size| UnionFind {
    parent : range(0, size).to_array,
    rank : Array::fill(size, 0),
    size : Array::fill(size, 1)
};

// 指定された要素の親を取得する
// 
// パス圧縮を行うため、UnionFindの状態も変化する
// 
// # Parameters
// - `x` : 対象となる要素
// - `uf` : UnionFind木
find_parent : I64 -> UnionFind -> (UnionFind, I64);
find_parent = |x, uf| (
    let y = uf.@parent.@(x);
    if y == x {
        (uf, x)
    } else {
        let (uf, y) = uf.find_parent(y);
        let uf = uf.mod_parent(set(x, y));
        (uf, y)
    }
);

// 2つの要素を同じグループにする
// 
// # Parameters
// - `x` : 1つ目の要素
// - `y` : 2つ目の要素
// - `uf` : UnionFind木
unite : I64 -> I64 -> UnionFind -> UnionFind;
unite = |x, y, uf| (
    let (uf, px) = uf.find_parent(x);
    let (uf, py) = uf.find_parent(y);
    if px == py {
        uf // すでに同じグループに属している場合は何もしない
    };
    let px_rank = uf.@rank.@(px);
    let py_rank = uf.@rank.@(py);
    let new_size = uf.@size.@(px) + uf.@size.@(py);
    if px_rank < py_rank {
        let uf = uf.mod_parent(set(px, py));
        uf.mod_size(set(py, new_size))
    } else if px_rank > py_rank {
        let uf = uf.mod_parent(set(py, px));
        uf.mod_size(set(px, new_size))
    } else { // rank[px] == rank[py]
        let uf = uf.mod_parent(set(py, px));
        let uf = uf.mod_rank(set(px, px_rank + 1));
        uf.mod_size(set(px, new_size))
    }
);

// 2つの要素が同じグループに属しているかどうかを判定する
// 
// パス圧縮を行うため、UnionFindの状態も変化する
// 
// # Parameters
// - `x` : 1つ目の要素 
// - `y` : 2つ目の要素
// - `uf` : UnionFind木
is_united : I64 -> I64 -> UnionFind -> (UnionFind, Bool);
is_united = |x, y, uf| (
    let (uf, px) = uf.find_parent(x);
    let (uf, py) = uf.find_parent(y);
    (uf, px == py)
);

// 指定された要素が属するグループのサイズを取得する
// 
// パス圧縮を行うため、UnionFindの状態も変化する
// 
// # Parameters
// - `x` : 対象となる要素
// - `uf` : UnionFind木
get_group_size : I64 -> UnionFind -> (UnionFind, I64);
get_group_size = |x, uf| (
    let (uf, px) = uf.find_parent(x);
    (uf, uf.@size.@(px))
);

// グループの配列を取得する
// 
// グループの配列[g0, g1, g2, ...]を返す
// 
// パス圧縮を行うため、UnionFindの状態も変化する
// 
// # Parameters
// - `uf` : UnionFind木
get_groups : UnionFind -> (UnionFind, Array (Array I64));
get_groups = |uf| (
    let n = uf.@parent.get_size;
    let grps = Array::fill(n, none());
    let (uf, grps) = range(0, uf.@parent.get_size).fold((uf, grps), |i, (uf, grps)| 
        let (uf, p) = uf.find_parent(i);
        let grps = grps.mod(p, |g| 
            match g {
                some(g) => some(g.push_back(i)),
                none() => some([i])
            }
        );
        (uf, grps)
    );
    let grps = grps.to_iter.filter_map(|g| g).to_array;
    (uf, grps)
);

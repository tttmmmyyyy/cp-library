// 素数`p`を法とする整数の環の型`ZP p`を与えるモジュール。
//
// 素数`p`は静的でなければならない（コンパイル時に決まる必要がある）。
// 
// 素数`p`は型パラメータとして与える。例として、p = 17 としたい場合、
// - 空の型（フィールドを持たないunboxedな型）`P17`を作成：`type P17 = unbox struct {}`.
// - `P17 : PrimeProvider`を実装する。この際`PrimeProvider::value`関数で17を返すようにする：`value = |_| 17_U32;`
// すると`ZP P17`が環"Z/(17)"を表す型となる。
//
// 幾つかの有名な素数nに対する PrimeProvider `Pn` はこのモジュールに定義されている。
// 
// 使用例：
// ```
// module Main;
//
// import CPLib.ZP;
//
// type P17 = unbox struct {};
//
// impl P17 : PrimeProvider {
//     create = P17 {};
//     value = |p| 17_U32;
// }
//
// main : IO ();
// main = (
//     let zp = ZP::make(-5) : ZP P17;
//     let zp = zp * zp;
//     assert_eq(|_|"case 1", zp.@value, 8_U32);; // (-5)*(-5) = 25 = 8 mod 17
//     pure()
// );
// ```
module CPLib.ZP;

import CPLib.Arithmetic;

// 素数`p`を法とする整数の環
type ZP p = struct { value : U32, prime : p };

trait p : PrimeProvider {
    create : p;
    value : p -> U32;
}

type P1000000007 = unbox struct {};

impl P1000000007 : PrimeProvider {
    create = P1000000007 {};
    value = |p| 1000000007_U32;
}

type P1000000009 = unbox struct {};

impl P1000000009 : PrimeProvider {
    create = P1000000009 {};
    value = |p| 1000000009_U32;
}

// NTT-friendly prime (2^23 | p-1)
type P998244353 = unbox struct {};

impl P998244353 : PrimeProvider {
    create = P998244353 {};
    value = |p| 998244353_U32;
}

// NTT-friendly prime (2^24 | p-1)
type P754974721 = unbox struct {};

impl P754974721 : PrimeProvider {
    create = P754974721 {};
    value = |p| 754974721_U32;
}

// NTT-friendly prime (2^25 | p-1)
type P167772161 = unbox struct {};

impl P167772161 : PrimeProvider {
    create = P167772161 {};
    value = |p| 167772161_U32;
}

// NTT-friendly prime (2^26 | p-1)
type P469762049 = unbox struct {};

impl P469762049 : PrimeProvider {
    create = P469762049 {};
    value = |p| 469762049_U32;
}

// `I64`から素数を作成する
// 
// # Parameters
// - `x` : `I64`型の整数
make : [p : PrimeProvider] I64 -> ZP p;
make = |x| (
    let pp = PrimeProvider::create;
    let p = pp.value;
    let x = x % p.to_I64;
    let x = if x < 0 { x + p.to_I64 } else { x };
    ZP { value : x.to_U32, prime : pp }
);

// x^e mod p を計算する。
// 
// xが0かつeが負のときはプログラムを終了する。
// 
// # Parameters
// - `x` : `ZP p`型の数
// - `e` : `I64`型の指数
power : [p : PrimeProvider] I64 -> ZP p -> ZP p;
power = |e, x| (
    if x.@value == 0_U32 && e < 0 {
        undefined("[ZP::power] divide by zero!")
    };
    let p = x.@prime.value;
    let p1 = p.to_I64 - 1;
    let e = e % p1;
    let e = if e < 0 { e + p1 } else { e };
    x._power_unsigned(e.to_U64)
);

// x^e mod p を計算する（eが非負整数のとき）
// 
// # Parameters
// - `x` : `ZP p`型の数
// - `e` : `I64`型の指数
_power_unsigned : [p : PrimeProvider] U64 -> ZP p -> ZP p;
_power_unsigned = |e, x| (
    loop((e, ZP::make(1), x), |(e, pow, x)|
        if e == 0_U64 { break $ pow };
        let pow = if e.bit_and(1_U64) == 1_U64 { pow * x } else { pow };
        continue $ (e.shift_right(1_U64), pow, x * x)
    )
);


// `ZP p`の逆元を求める。
// 
// 0を与えた場合はプログラムを終了する。
//
// # Parameters
// - `x` : `ZP p`型の整数
inv : [p : PrimeProvider] ZP p -> ZP p;
inv = |x| (
    let p = x.@prime.value;
    if x.@value == 0_U32 { undefined("[ZP::inv] divide by zero!") };
    x.power(p.to_I64 - 2)
);

// 1の原始根を一つ得る
primitive_root : [p : PrimeProvider] ZP p;
primitive_root = (
    let pp = PrimeProvider::create;
    let p = pp.value;
    let r = calc_primitive_root(p.to_I64);
    ZP { value : r.to_U32, prime : pp }
);

impl [p : PrimeProvider] ZP p : Eq {
    eq = |this, that| (
        let p = this.@prime.value;
        this.@value == that.@value
    );
}

impl [p : PrimeProvider] ZP p : Add {
    add = |this, that| (
        let p = this.@prime.value;
        let v = this.@value + that.@value;
        let v = if v >= p { v - p } else { v };
        ZP { value : v, prime : this.@prime }
    );
}

impl [p : PrimeProvider] ZP p : Neg {
    neg = |this| (
        let p = this.@prime.value;
        let v = p - this.@value;
        let v = if v >= p { v - p } else { v };
        ZP { value : v, prime : this.@prime }
    );
}

impl [p : PrimeProvider] ZP p : Sub {
    sub = |this, that| (
        let p = this.@prime.value;
        let v = this.@value;
        let v = if v < that.@value { v + p } else { v };
        let v = v - that.@value;
        ZP { value : v, prime : this.@prime }
    );
}

impl [p : PrimeProvider] ZP p : Mul {
    mul = |this, that| (
        let p = this.@prime.value.to_U64;
        ZP { value : ((this.@value.to_U64 * that.@value.to_U64) % p).to_U32, prime : this.@prime }
    );
}

impl [p : PrimeProvider] ZP p : Div {
    div = |this, that| this * that.inv;
}

impl ZP p : ToString {
    to_string = |this| this.@value.to_string;
}

// 与えられた64ビット整数と等しいかより大きい最小の2のべき乗を計算する
// 
// # Parameters
// - `x`: 64ビット整数
_calc_next_pot : U64 -> U64;
_calc_next_pot = |n| (
    if n <= 1_U64 { 1_U64 };
    let n = n - 1_U64;
    let n = n.bit_or(n.shift_right(1_U64));
    let n = n.bit_or(n.shift_right(2_U64));
    let n = n.bit_or(n.shift_right(4_U64));
    let n = n.bit_or(n.shift_right(8_U64));
    let n = n.bit_or(n.shift_right(16_U64));
    let n = n.bit_or(n.shift_right(32_U64));
    n + 1_U64
);

// 高速フーリエ変換の方向（順方向か逆方向か）を表す型
type FFTDirection = union {
    forward : (),
    inverse : (),
};

// `ZP p`型の配列に対して高速フーリエ変換を行う
//
// 制約：2^c|(p-1)かつ|x| <= 2^cなるcが存在する
//
// # Parameters
// - `dir` : FFTの方向（順方向か逆方向か）
// - `x` : `ZP p`型の配列
fft : [p : PrimeProvider] FFTDirection -> Array (ZP p) -> Array (ZP p);
fft = |dir, x| (
    // 空配列はそのまま返す
    if x.get_size == 0 { x };

    // xの長さを2のべき乗にする
    let n = x.get_size;
    let pot = _calc_next_pot(n.to_U64).to_I64;
    let x = x.reserve(pot);
    let x = range(n, pot).fold(x, |i, x| x.push_back(ZP::make(0)));
    let n = pot;

    // p - 1 = 2^k * c (c: 奇数) と分解し、2^k >= n であることを確認し、1のn乗根wを計算する
    let p = x.@(0).@prime.value.to_I64;
    let pm1 = p - 1;
    let two_k = pm1.bit_and(-pm1);
    if two_k < n { undefined("[fft_zp] p - 1 is not enough for the size of x.") };
    let d = pm1 / n;
    let w = ZP::primitive_root._power_unsigned(d.to_U64);
    let w = match dir { forward() => w, inverse() => w.inv };

    // bit-reversal permutation
    let (_, x) = range(1, n).fold((0, x), |i, (j, x)|
        // iをビット反転したものをjに設定
        // ループによりiが1増えているので、jには「上位ビット側から1を加える」
        let bit = n.shift_right(1); 
        let j = loop((bit, j), |(bit, j)|
            if j.bit_and(bit) == 0 { break $ j.bit_xor(bit) };
            let j = j.bit_xor(bit);
            let bit = bit.shift_right(1);
            continue $ (bit, j)
        );
        
        let x = if i < j { x._unsafe_swap(i, j) } else { x };
        (j, x)
    );

    // 2 <= len <= n（lenは2のべき））の範囲で、1のlen乗根を計算しておく（逆順）。
    let wlens = loop((n, Array::empty(32), w), |(len, wlens, w)|
        if len == 1 { break $ wlens };
        let wlens = wlens.push_back(w);
        let w = w * w;
        continue $ (len.shift_right(1), wlens, w)
    );

    let x = loop((1, x), |(log_len, x)|
        let len = 1.shift_left(log_len);
        if len > n { break $ x };
        let wlen = wlens.@(wlens.get_size - log_len); // 1のlen乗根
        let x = range_step(0, n, len).fold(x, |i, x|
            let w = ZP::make(1);
            let (_w, x) = range(0, len / 2).fold((w, x), |j, (w, x)|
                let (x, u) = x._unsafe_get_linear(i+j);
                let (x, v) = x._unsafe_get_linear(i+j+len/2);
                let v = v * w;
                let x = x.set(i+j, u + v);
                let x = x._unsafe_set(i+j+len/2, u - v);
                (w * wlen, x)
            );
            x
        );
        continue $ (log_len + 1, x)
    );

    // 逆変換の場合は、nで割る
    match dir {
        forward() => x,
        inverse() => (
            let ni = ZP::make(n).inv;
            x.map(|v| v * ni)
        )
    }
);
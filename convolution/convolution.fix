module CPLib.Convolution;

import CPLib.Arithmetic::{_inv_gcd, pmod};
import CPLib.ZP::{
    _calc_next_pot, fft, make, P167772161, P469762049, P754974721, PrimeProvider, ZP, 
    FFTDirection::{forward, inverse}, ZP::@value
};
import Std::{
    undefined, Array, I64, 
    Array::{@, _unsafe_set_bounds_uniqueness_unchecked_unreleased, fill, get_size, push_back, reserve, truncate}, 
    Functor::map, I64::shift_left, Iterator::{fold, range}, ToI64::i64, ToU64::u64, Tuple2::@1
};

// 2つの配列の畳み込みを計算する
// 
// 結果は、要素数が`|a| + |b| - 1`の配列になります。
//
// 制約：2^c|(p-1)かつ|a| + |b| - 1 <= 2^cなるcが存在する
// 
// # Parameters
// - `a` : 畳み込まれる配列1
// - `b` : 畳み込まれる配列2
convolve_zp : [p : PrimeProvider] Array (ZP p) -> Array (ZP p) -> Array (ZP p);
convolve_zp = |x, y| (
    if x.get_size == 0 || y.get_size == 0 { [] };

    // xとyの長さを同じ2のべき乗にする
    let n = x.get_size + y.get_size - 1;
    let pot = _calc_next_pot(n.u64).i64;
    let x = x.reserve(pot);
    let x = range(x.get_size, pot).fold(x, |i, x| x.push_back(ZP::make(0)));
    let y = y.reserve(pot);
    let y = range(y.get_size, pot).fold(y, |i, y| y.push_back(ZP::make(0)));

    let x = x.ZP::fft(forward());
    let y = y.ZP::fft(forward());

    // xとyの各要素を掛け合わせる
    let x = range(0, pot).fold(x, |i, x| x._unsafe_set_bounds_uniqueness_unchecked_unreleased(i, x.@(i) * y.@(i)));

    // 逆変換を行う
    let x = x.ZP::fft(inverse());

    // サイズを元に戻す
    x.truncate(n)
);

// 2つの整数配列の畳み込みを計算する
// 
// 結果は、要素数が`|a| + |b| - 1`の配列になります。
// 
// 制約：
// - |a| + |b| - 1 <= 2^24
// - 結果が`I64`の範囲でオーバーフローしない
//
// # Parameters
// - `a` : 畳み込まれる配列1
// - `b` : 畳み込まれる配列2
convolve_i64 : Array I64 -> Array I64 -> Array I64;
convolve_i64 = |a, b| (
    // 実装参考：https://github.com/atcoder/ac-library/blob/master/atcoder/convolution.hpp#L269
    let n = a.get_size;
    let m = b.get_size;
    if n == 0 || m == 0 { [] };
    if n + m - 1 > 1.shift_left(24) { undefined("[convolve_i64] n + m - 1 > 2^24") };

    let _M1 = 754974721_U64; // 2^24
    let _M2 = 167772161_U64; // 2^25
    let _M3 = 469762049_U64; // 2^26
    let _M1M2 = _M1 * _M2;
    let _M1M3 = _M1 * _M3;
    let _M2M3 = _M2 * _M3;
    let _M1M2M3 = _M1M2 * _M3;

    let c1 = convolve_zp(a.map(make), b.map(make)) : Array (ZP P754974721);
    let c2 = convolve_zp(a.map(make), b.map(make)) : Array (ZP P167772161);
    let c3 = convolve_zp(a.map(make), b.map(make)) : Array (ZP P469762049);

    let i1 = _inv_gcd(_M2M3.i64, _M1.i64).@1.u64;
    let i2 = _inv_gcd(_M1M3.i64, _M2.i64).@1.u64;
    let i3 = _inv_gcd(_M1M2.i64, _M3.i64).@1.u64;

    let offset = [0_U64, 0_U64, _M1M2M3, 2_U64 * _M1M2M3, 3_U64 * _M1M2M3];

    let c = Array::fill(n + m - 1, 0);
    range(0, n + m - 1).fold(c, |i, c|
        let x = 0_U64;
        let x = x + (c1.@(i).@value.u64 * i1) % _M1 * _M2M3;
        let x = x + (c2.@(i).@value.u64 * i2) % _M2 * _M1M3;
        let x = x + (c3.@(i).@value.u64 * i3) % _M3 * _M1M2;

        let diff = c1.@(i).@value.i64 - x.i64.pmod(_M1.i64);
        let diff = if diff < 0 { diff + _M1.i64 } else { diff };
        let x = x - offset.@(diff % 5);
        c._unsafe_set_bounds_uniqueness_unchecked_unreleased(i, x.i64)
    )
);
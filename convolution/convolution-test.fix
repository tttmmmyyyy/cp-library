module CPLib.Convolution.Test;

// https://atcoder.jp/contests/language-test-202505/submissions/68393185

import CPLib.Convolution;
import CPLib.ZP;
import CPLib.Arithmetic;

type P17 = unbox struct {};

impl P17 : PrimeProvider {
    create = P17 {};
    value = |p| 17_U32;
}

test : IO ();
test = (
    test_zp;;
    test_i64;;
    pure()
);

test_zp : IO ();
test_zp = (
    // p = 17, 基本
    let x = [ZP::make(1), ZP::make(2), ZP::make(3)] : Array (ZP P17);
    let y = [ZP::make(4), ZP::make(5), ZP::make(6)] : Array (ZP P17);
    let z = convolve_zp(x, y);
    assert_eq(|_|"[test_zp] case 1", z.@(0), x.@(0) * y.@(0));;
    assert_eq(|_|"[test_zp] case 2", z.@(1), x.@(0) * y.@(1) + x.@(1) * y.@(0));;
    assert_eq(|_|"[test_zp] case 3", z.@(2), x.@(0) * y.@(2) + x.@(1) * y.@(1) + x.@(2) * y.@(0));;
    assert_eq(|_|"[test_zp] case 4", z.@(3), x.@(1) * y.@(2) + x.@(2) * y.@(1));;
    assert_eq(|_|"[test_zp] case 5", z.@(4), x.@(2) * y.@(2));;
    assert_eq(|_|"[test_zp] case 6", z.get_size, x.get_size + y.get_size - 1);;

    // p = 17, 長さギリギリ
    let x = range(0, 16).map(ZP::make).to_array : Array (ZP P17);
    let y = [ZP::make(1)];
    let z = convolve_zp(x, y);
    assert_eq(|_|"[test_zp] case 7", z, x);;

    // p = 998244353, 基本
    let x = [ZP::make(1), ZP::make(2), ZP::make(3)] : Array (ZP P998244353);
    let y = [ZP::make(4), ZP::make(5), ZP::make(6)] : Array (ZP P998244353);
    let z = convolve_zp(x, y);
    assert_eq(|_|"[test_zp] case 8", z.@(0), x.@(0) * y.@(0));;
    assert_eq(|_|"[test_zp] case 9", z.@(1), x.@(0) * y.@(1) + x.@(1) * y.@(0));;
    assert_eq(|_|"[test_zp] case 10", z.@(2), x.@(0) * y.@(2) + x.@(1) * y.@(1) + x.@(2) * y.@(0));;
    assert_eq(|_|"[test_zp] case 11", z.@(3), x.@(1) * y.@(2) + x.@(2) * y.@(1));;
    assert_eq(|_|"[test_zp] case 12", z.@(4), x.@(2) * y.@(2));;
    assert_eq(|_|"[test_zp] case 13", z.get_size, x.get_size + y.get_size - 1);;

    // p = 998244353, 長さギリギリ
    let x = range(0, 1.shift_left(23)).map(ZP::make).to_array : Array (ZP P998244353);
    let y = [ZP::make(1)];
    let (z, time) = consumed_time_while_lazy(|_| convolve_zp(x, y));
    assert_eq(|_|"[test_zp] case 14", z, x);;

    // ベンチマーク
    let n = 1e5;
    let x = range(0, n).map(ZP::make).to_array : Array (ZP P998244353);
    let y = range(0, n).map(ZP::make).to_array : Array (ZP P998244353);
    let (z, time) = consumed_time_while_lazy(|_| convolve_zp(x, y));
    let ans_n1 = range(0, n).fold(ZP::make(0), |i, acc| acc + x.@(i) * y.@(n-1-i));
    assert_eq(|_|"[test_zp] case 15", z.@(n-1), ans_n1);;
    println $ "[CPLib.Convolution.Test] convolve_zp({}): {}".populate([n.to_string, time.to_string]);;

    pure()
);

test_i64 : IO ();
test_i64 = (
    // 基本
    let x = [1, 2, 3];
    let y = [4, 5, 6];
    let z = convolve_i64(x, y);
    assert_eq(|_|"[test_i64] case 1", z.@(0), x.@(0) * y.@(0));;
    assert_eq(|_|"[test_i64] case 2", z.@(1), x.@(0) * y.@(1) + x.@(1) * y.@(0));;
    assert_eq(|_|"[test_i64] case 3", z.@(2), x.@(0) * y.@(2) + x.@(1) * y.@(1) + x.@(2) * y.@(0));;
    assert_eq(|_|"[test_i64] case 4", z.@(3), x.@(1) * y.@(2) + x.@(2) * y.@(1));;
    assert_eq(|_|"[test_i64] case 5", z.@(4), x.@(2) * y.@(2));;
    assert_eq(|_|"[test_i64] case 6", z.get_size, x.get_size + y.get_size - 1);;

    // オーバーフローのテスト
    let x = [I64::maximum, I64::minimum];
    let y = [1, 1, 1];
    let z = convolve_i64(x, y);
    assert_eq(|_|"[test_i64] case 7", z.@(0), x.@(0) * y.@(0));;
    assert_eq(|_|"[test_i64] case 8", z.@(1), x.@(0) * y.@(1) + x.@(1) * y.@(0));;
    assert_eq(|_|"[test_i64] case 9", z.@(2), x.@(0) * y.@(2) + x.@(1) * y.@(1));;
    assert_eq(|_|"[test_i64] case 10", z.@(3), x.@(1) * y.@(2));;
    assert_eq(|_|"[test_i64] case 11", z.get_size, x.get_size + y.get_size - 1);;

    pure()
);
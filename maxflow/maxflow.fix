//　最大フロー問題、最小カット問題
module CPLib.MaxFlow;

import CPLib.Graph;
import CPLib.Trait;
import RingBuffer;

// 容量に要求されるトレイト
trait CapacityLike = Additive + Neg + LessThan + Eq + Inf;

// 最大フロー問題のグラフの型
// 
// 型パラメータ`c`は容量の型です。
type MaxFlowGraph c = struct {
    // グラフ。`(現在の容量, 逆辺のインデックス, 初期容量)`
    graph : Graph (c, I64, c),
    // 開始地点
    s : I64,
    // 終了地点
    t : I64,
    // レベル。残余グラフ上での開始地点から任意の地点への距離。到達できない場合は-1。
    level : Array I64,
    // DFSにおいて次に調べる辺のインデックス
    iter : Array I64,
    // BFSで用いるキュー
    queue : Option (RingBuffer I64),
};

namespace MaxFlowGraph {
    // グラフを作成する
    // 
    // # Parameters
    // - `n` : 頂点数
    // - `s` : 開始頂点番号
    // - `t` : 終了頂点番号
    create : I64 -> I64 -> I64 -> MaxFlowGraph c;
    create = |n, s, t| (
        MaxFlowGraph { 
            graph : Graph::create(n),
            s : s,
            t : t,
            level : [],
            iter : [],
            queue : some $ RingBuffer::create([])
        }
    );

    // グラフに辺を追加する
    // 
    // 追加された辺の識別子を返す。
    // 
    // # Parameters
    // - `graph` : グラフ
    // - `from` : 始点の頂点番号
    // - `to` : 終点の頂点番号
    // - `cap` : 辺の容量
    add_edge : [c : CapacityLike] I64 -> I64 -> c -> MaxFlowGraph c -> MaxFlowGraph c;
    add_edge = |from, to, cap, g| g.add_edge_id(from, to, cap).@0;

    // グラフに辺を追加する（辺IDを返す）
    // 
    // 追加された辺の識別子を返す。
    // 
    // # Parameters
    // - `graph` : グラフ
    // - `from` : 始点の頂点番号
    // - `to` : 終点の頂点番号
    // - `cap` : 辺の容量
    add_edge_id : [c : CapacityLike] I64 -> I64 -> c -> MaxFlowGraph c -> (MaxFlowGraph c, EdgeId);
    add_edge_id = |from, to, cap, g| (
        let reve_idx = g.@graph.@edges.@(to).get_size;  // 次に`to`に追加される予定の辺のインデックス
        let data = (cap, reve_idx, cap);
        let g = g.(mod_graph $ add_edge(from, to, data));
        let eidx = g.@graph.@edges.@(from).get_size - 1;
        
        let data = (zero, eidx, zero);
        let g = g.(mod_graph $ add_edge(to, from, data));

        (g, EdgeId { from : from, idx : eidx })
    );

    // ある辺に流れているフローを取得する
    // 
    // # Parameters
    // - `eid` : `add_edge`で得た辺の識別子
    // - `graph` : グラフ
    get_flow : [c : CapacityLike] EdgeId -> MaxFlowGraph c -> c;
    get_flow = |eid, graph| (
        let (current, _, init) = graph.@graph.get_edge(eid).@data;
        init + (-current)
    );

    // 最大フローを計算する
    // 
    // 残余グラフと流されたフローの量を返す。
    //
    // # Parameters
    // - `graph` : グラフ
    maximize_flow : [c : CapacityLike] MaxFlowGraph c -> (MaxFlowGraph c, c);
    maximize_flow = |graph| graph.Dinic::solve;

    // 最小カットを取得する
    // 
    // 先に`maximize_flow`を呼び出しておく必要がある。
    // 
    // `s`から到達可能な頂点を`true`、到達不可能な頂点を`false`とする配列を返す。
    // 
    // 注：最小カットにおいて除去される辺の容量の和は`maximize_flow`で得られたフローの量に等しい。
    // 
    // # Parameters
    // - `graph` : グラフ
    get_min_cut : [c : CapacityLike] MaxFlowGraph c -> Array Bool;
    get_min_cut = |g| g.@level.map(|l| l >= 0);

    // ある辺にフローを流す
    // 
    // # Parameters
    // - `v` : 始点の頂点番号
    // - `e` : 辺のインデックス
    // - `f` : 流すフローの量
    // - `graph` : グラフ
    _add_flow : [c : CapacityLike] I64 -> I64 -> c -> MaxFlowGraph c -> MaxFlowGraph c;
    _add_flow = |v, e, f, g| (
        let (rv, re) = g.@graph.@edges.@(v).@(e).|e| (e.@to, e.@data.@1); // 逆辺の(v, e)
        let g = g.(mod_graph $ mod_edges $ mod(v) $ mod(e) $ mod_data $ mod_0 $ add(-f));
        let g = g.(mod_graph $ mod_edges $ mod(rv) $ mod(re) $ mod_data $ mod_0 $ add(f));
        g
    );
}

// Dinicアルゴリズム
namespace Dinic {
    // 最大フローを求める
    solve : [c : CapacityLike] MaxFlowGraph c -> (MaxFlowGraph c, c);
    solve = |self| (
        let flow = zero; 
        loop((self, flow), |(self, flow)|
            // BFSしてレベルを更新
            let self = self.bfs;
            // 残余グラフ上で開始地点から終了地点に到達できない場合は終了
            if self.@level.@(self.@t) < 0 { 
                break $ (self, flow)
            };
            // DFSを繰り返す
            let self = self.reset_iter;
            continue $ loop((self, flow), |(self, flow)|
                let (self, f) = self.dfs(self.@s, Inf::inf);
                if f == zero { break $ (self, flow) };
                let flow = flow + f;
                continue $ (self, flow)
            )
        )
    );

    // `iter`をすべて0にリセットする。
    reset_iter : MaxFlowGraph c -> MaxFlowGraph c;
    reset_iter = |self| (
        let n = self.@graph.get_size;
        if self.@iter.get_size != n {
            self.set_iter(Array::fill(n, 0))
        } else {
            self.(mod_iter $ |iter| range(0, iter.get_size).fold(iter, |i, iter| iter.set(i, 0)))
        }
    );

    // `level`をすべて-1にリセットする。
    reset_level : MaxFlowGraph c -> MaxFlowGraph c;
    reset_level = |self| (
        let n = self.@graph.get_size;
        if self.@level.get_size != n {
            self.set_level(Array::fill(n, -1))
        } else {
            self.(mod_level $ |level| range(0, level.get_size).fold(level, |i, level| level.set(i, -1)))
        }
    );

    // 残余グラフ上でBFSしてレベルを更新する
    bfs : [c : CapacityLike] MaxFlowGraph c -> MaxFlowGraph c;
    bfs = |self| (
        // レベルを初期化
        let self = self.reset_level;
        // `self.@queue`を`none()`とスワップ
        let (queue, self) = self.act_queue(|q| (q, none()));
        let queue = queue.as_some;
        // 開始地点を訪問
        let self = self.mod_level(set(self.@s, 0));
        let queue = queue.push_back(self.@s);
        // BFS
        loop((self, queue), |(self, queue)|
            let v = queue.get_front;
            let queue = queue.pop_front;            
            if v.is_none {
                // キューが空なら`self.@queue`に戻して終了
                break $ self.set_queue(some $ queue)
            };
            let v = v.as_some;
            let v_edges = self.@graph.@edges.@(v);
            continue $ v_edges.to_iter.fold((self, queue), |e, (self, queue)|
                if e.@data.@0 > zero && self.@level.@(e.@to) < 0 {
                    // 残余容量があるかつ未訪問なら、`e.@to`を訪問
                    let self = self.mod_level(set(e.@to, self.@level.@(v) + 1));
                    let queue = queue.push_back(e.@to); // キューに追加
                    (self, queue)
                } else { 
                    (self, queue)
                }
            )
        )
    );

    // 開始地点からの最短経路DAG（`level`から得られる）においてDFSして経路を一つ発見し、フロー・残余グラフを更新する。
    //
    // 更新された残余グラフと、新たに流されたフローの量を返す。
    // 
    // 一度調べた辺を次の`dfs`で調べないよう、`iter`を更新する。
    // 
    // # Parameters
    // - `v` : 現在の頂点
    // - `f` : 流してよいフローの量
    dfs : [c : CapacityLike] I64 -> c -> MaxFlowGraph c -> (MaxFlowGraph c, c);
    dfs = |v, f, self| (
        // 終了地点に到達したら終了
        if v == self.@t { (self, f) };
        // 未探索の残余グラフの辺に沿ってループ
        let v_edges = self.@graph.@edges.@(v);
        match range(self.@iter.@(v), v_edges.get_size).loop_iter_s(self, |i, self|
            let self = self.mod_iter(set(v, i));
            let e = v_edges.@(i);
            // 残余グラフの辺でないか、最短経路DAGに沿っていない辺なら、スキップする
            if !(e.@data.@0 > zero && self.@level.@(v) < self.@level.@(e.@to)) {
                continue $ self
            };             
            // DFSでフローを流そうとする
            let (self, d) = self.dfs(e.@to, min(f, e.@data.@0));
            // この辺に沿ってフローを流すことに失敗したら、次の辺を調べる
            if d == zero {
                continue $ self
            };
            // 残余グラフを更新する
            let self = self._add_flow(v, i, d);
            break $ (self, d)
        ) {
            break(self_f) => (
                // フローを流せるパスを見つけたとき
                self_f
            ),
            continue(self) => (
                // フローを流せるパスを見つけられなかったとき
                (self, zero)
            )
        }
    );
}
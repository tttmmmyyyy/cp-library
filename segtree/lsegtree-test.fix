module CPLib.LSegtree.Test;

import CPLib.Trait;
import CPLib.Arithmetic::pmod;
import CPLib.LSegtree;

import Random;

// 文字列の結合に関するモノイド
type StrConcat = struct { v : String };
namespace StrConcat {
    make : String -> StrConcat;
    make = |v| StrConcat { v : v };
}
impl StrConcat : Monoid {
    unit = make("");
    op = |lhs, rhs| make $ lhs.@v + rhs.@v;
}
impl StrConcat : Eq {
    eq = |lhs, rhs| lhs.@v == rhs.@v;
}
impl StrConcat : ToString {
    to_string = |a| a.@v;
}

test : IO ();
test = (
    let rng = Random::init_by_seed(0_U64);
    let rng = *test_random(false, rng);
    let rng = *test_random(true, rng);

    pure()
);

// 文字ごとにアフィン変換（mod 26）を行うモノイド
type ShiftAlphabet = struct { a : I64, b : I64 };
namespace ShiftAlphabet {
    make : I64 -> I64 -> ShiftAlphabet;
    make = |a, b| ShiftAlphabet { a : a.pmod(26), b : b.pmod(26) };
}
impl ShiftAlphabet : Monoid {
    unit = make(1, 0);
    op = |lhs, rhs| (
        let a = lhs.@a;
        let b = lhs.@b;
        let c = rhs.@a;
        let d = rhs.@b;
        // lhs(x) = ax + b, rhs(x) = cx + d,
        // x・lhs・rhs = rhs(lhs(x)) = c(ax + b) + d = cax + cb + d
        let e = (c * a).pmod(26);
        let f = (c * b + d).pmod(26);
        make(e, f)
    );
}
impl ShiftAlphabet : ToString {
    to_string = |a| "({}, {})".populate([a.@a.to_string, a.@b.to_string]);
}

// 作用の定義
impl ShiftAlphabet : Action {
    type Set ShiftAlphabet = StrConcat;
    act = |a, s| (
        let bytes = s.@v.get_bytes;
        let bytes = bytes.map(|x| 
            if x == '\0' { x }; // ヌル文字は変換しない
            let x = (x - 'a').to_I64;
            let x = (a.@a * x + a.@b).pmod(26);
            let x = x.to_U8 + 'a';
            x
        );
        let s = String::_unsafe_from_c_str(bytes);
        StrConcat::make(s)
    );
}

// ランダムな数文字のアルファベット文字列を生成する
gen_random_alphabetical_string : Random -> (Random, String);
gen_random_alphabetical_string = |rng| (
    let (rng, len) = rng.generate_I64_nonneg;
    let len = len % 6; // 0～5文字
    let (bytes, rng) = range(0, len).fold(([], rng), |_, (bytes, rng)|
        let (rng, c) = rng.generate_I64_nonneg;
        let c = (c % 26).to_U8 + 'a';
        let bytes = bytes.push_back(c);
        (bytes, rng)
    );
    let bytes = bytes.push_back('\0');
    let s = String::_unsafe_from_c_str(bytes);
    (rng, s)
);

test_random : Bool -> Random -> IO Random;
test_random = |is_build, rng| (
    // n要素のセグメント木に対してランダムな操作を行う
    let n = 100;

    let (tree, arr) = if !is_build {
        let arr = Array::fill(n, StrConcat::make(""));
        (LSegtree::init(n), arr)
    } else {
        let arr = range(0, n).map(|i| 
            let v = String::from_U8('a' + (i % 26).to_U8);
            StrConcat::make(v)
        ).to_array;
        (LSegtree::build(arr), arr)
    };

    let (_1, _2, rng) = *range(0, 1000).fold_m((tree, arr, rng), |_, (tree, arr, rng)|
        let (rng, dice) = rng.generate_I64_nonneg;
        let dice = dice % 2;
        let (tree, arr, rng) = *if dice == 0 {
            // setによる更新
            let (rng, i) = rng.generate_I64_nonneg;
            let i = i % n;
            let (rng, v) = rng.gen_random_alphabetical_string;
            let v = StrConcat::make(v);
            let tree = tree.set(i, v);
            let arr = arr.set(i, v);
            pure $ (tree, arr, rng)
        } else {
            // 範囲作用による更新
            let (rng, l) = rng.generate_I64_nonneg;
            let (rng, r) = rng.generate_I64_nonneg;
            let l = l % n;
            let r = l + r % (n - l + 1);
            let (rng, a) = rng.generate_I64_nonneg;
            let (rng, b) = rng.generate_I64_nonneg;
            let a = ShiftAlphabet::make(a, b);
            let tree = tree.act_range(l, r, a);
            let arr = range(l, r).fold(arr, |i, arr| arr.set(i, act(a, arr.@(i))));
            pure $ (tree, arr, rng)
        };

        // foldを実行
        let (rng, l) = rng.generate_I64_nonneg;
        let (rng, r) = rng.generate_I64_nonneg;
        let l = l % n;
        let r = l + r % (n - l + 1);
        let (tree, v) = tree.fold(l, r);
        let w = range(l, r).fold(Monoid::unit, |i, acc| Monoid::op(acc, arr.@(i)));
        assert_eq(|_|"lsegtree random", v, w);;

        pure $ (tree, arr, rng)
    );

    pure $ rng
);
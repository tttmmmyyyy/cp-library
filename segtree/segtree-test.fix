module CPLib.Segtree.Test;

import CPLib.Segtree;
import CPLib.Trait::{Monoid, Monoid::*};

test : IO ();
test = (
    test_one;;
    test_two;;
    test_three;;

    pure()
);

// 文字列の結合に関するモノイド
type StrConcat = struct { v : String };
namespace StrConcat {
    make : String -> StrConcat;
    make = |v| StrConcat { v : v };
}
impl StrConcat : Monoid {
    unit = make("");
    op = |lhs, rhs| make $ lhs.@v + rhs.@v;
}
impl StrConcat : Eq {
    eq = |lhs, rhs| lhs.@v == rhs.@v;
}

// 1要素のセグメント木のテスト
test_one : IO ();
test_one = (
    // [""]
    let tree = Segtree::init(1);
    assert_eq(|_|"", tree.@n, 1);;
    assert_eq(|_|"", tree.@(0), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(0, 1), StrConcat::make(""));;

    // set @(0) to "a": ["a"]
    let tree = tree.set(0, StrConcat::make("a"));
    assert_eq(|_|"", tree.@(0), StrConcat::make("a"));;
    assert_eq(|_|"", tree.fold(0, 1), StrConcat::make("a"));;

    // build ["a"]
    let tree = Segtree::build([StrConcat::make("a")]);
    assert_eq(|_|"", tree.@n, 1);;
    assert_eq(|_|"", tree.@(0), StrConcat::make("a"));;
    assert_eq(|_|"", tree.fold(0, 1), StrConcat::make("a"));;

    pure()
);

// 2要素のセグメント木のテスト
test_two : IO ();
test_two = (
    // ["", ""]
    let tree = Segtree::init(2);
    assert_eq(|_|"", tree.@n, 2);;
    assert_eq(|_|"", tree.@(0), StrConcat::make(""));;
    assert_eq(|_|"", tree.@(1), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(0, 1), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(1, 2), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(0, 2), StrConcat::make(""));;

    // set @(0) to "a": ["a", ""]
    let tree = tree.set(0, StrConcat::make("a"));
    assert_eq(|_|"", tree.@(0), StrConcat::make("a"));;
    assert_eq(|_|"", tree.@(1), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(0, 1), StrConcat::make("a"));;
    assert_eq(|_|"", tree.fold(1, 2), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(0, 2), StrConcat::make("a"));;

    // set @(1) to "b": ["a", "b"]
    let tree = tree.set(1, StrConcat::make("b"));
    assert_eq(|_|"", tree.@(0), StrConcat::make("a"));;
    assert_eq(|_|"", tree.@(1), StrConcat::make("b"));;
    assert_eq(|_|"", tree.fold(0, 1), StrConcat::make("a"));;
    assert_eq(|_|"", tree.fold(1, 2), StrConcat::make("b"));;
    assert_eq(|_|"", tree.fold(0, 2), StrConcat::make("ab"));;

    // build ["a", "b"]
    let tree = Segtree::build(["a", "b"].map(StrConcat::make));
    assert_eq(|_|"", tree.@n, 2);;
    assert_eq(|_|"", tree.@(0), StrConcat::make("a"));;
    assert_eq(|_|"", tree.@(1), StrConcat::make("b"));;
    assert_eq(|_|"", tree.fold(0, 1), StrConcat::make("a"));;
    assert_eq(|_|"", tree.fold(1, 2), StrConcat::make("b"));;
    assert_eq(|_|"", tree.fold(0, 2), StrConcat::make("ab"));;

    pure()
);

// 3要素のセグメント木のテスト
test_three : IO ();
test_three = (
    // ["", "", ""]
    let tree = Segtree::init(3);
    assert_eq(|_|"", tree.@n, 3);;
    assert_eq(|_|"", tree.@(0), StrConcat::make(""));;
    assert_eq(|_|"", tree.@(1), StrConcat::make(""));;
    assert_eq(|_|"", tree.@(2), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(0, 1), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(1, 2), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(2, 3), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(0, 2), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(1, 3), StrConcat::make(""));;
    assert_eq(|_|"", tree.fold(0, 3), StrConcat::make(""));;
    
    // update to ["a", "b", "c"]
    let tree = tree.set(1, StrConcat::make("b")).set(2, StrConcat::make("c")).set(0, StrConcat::make("a"));
    assert_eq(|_|"", tree.@(0), StrConcat::make("a"));;
    assert_eq(|_|"", tree.@(1), StrConcat::make("b"));;
    assert_eq(|_|"", tree.@(2), StrConcat::make("c"));;
    assert_eq(|_|"", tree.fold(0, 1), StrConcat::make("a"));;
    assert_eq(|_|"", tree.fold(1, 2), StrConcat::make("b"));;
    assert_eq(|_|"", tree.fold(2, 3), StrConcat::make("c"));;
    assert_eq(|_|"", tree.fold(0, 2), StrConcat::make("ab"));;
    assert_eq(|_|"", tree.fold(1, 3), StrConcat::make("bc"));;
    assert_eq(|_|"", tree.fold(0, 3), StrConcat::make("abc"));;

    // build ["a", "b", "c"]
    let tree = Segtree::build(["a", "b", "c"].map(StrConcat::make));
    assert_eq(|_|"", tree.@n, 3);;
    assert_eq(|_|"", tree.@(0), StrConcat::make("a"));;
    assert_eq(|_|"", tree.@(1), StrConcat::make("b"));;
    assert_eq(|_|"", tree.@(2), StrConcat::make("c"));;
    assert_eq(|_|"", tree.fold(0, 1), StrConcat::make("a"));;
    assert_eq(|_|"", tree.fold(1, 2), StrConcat::make("b"));;
    assert_eq(|_|"", tree.fold(2, 3), StrConcat::make("c"));;
    assert_eq(|_|"", tree.fold(0, 2), StrConcat::make("ab"));;
    assert_eq(|_|"", tree.fold(1, 3), StrConcat::make("bc"));;
    assert_eq(|_|"", tree.fold(0, 3), StrConcat::make("abc"));;

    pure()
);
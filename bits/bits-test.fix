module CPLib.Bits.Test;

import CPLib.Bits::{
    bit_check, bit_clear, bit_combinations, bit_flip, bit_set, bit_subsets, I32::popcount, I64::popcount, 
    ToStringBits::to_string_bits, U32::popcount, U64::popcount
};
import Std::{
    IO, Array::get_size, Debug::assert_eq, Functor::map, I64::shift_left, Iterator::to_array, 
    Monad::pure, ToString::to_string
};

test : IO () = (
    test_bit_combinations;;
    test_bit_subsets;;
    test_bit_operations;;
    test_popcount;;
    pure()
);

test_bit_combinations : IO () = (
    let combs = bit_combinations(0, -1).to_array;
    assert_eq(|_|"test_bit_combinations 0 -1", combs.map(to_string_bits(8)).to_string, "[]");;

    let combs = bit_combinations(0, 0).to_array;
    assert_eq(|_|"test_bit_combinations 0 0", combs.map(to_string_bits(8)).to_string, "[00000000]");;

    let combs = bit_combinations(0, 1).to_array;
    assert_eq(|_|"test_bit_combinations 0 1", combs.map(to_string_bits(8)).to_string, "[]");;

    let combs = bit_combinations(1, -1).to_array;
    assert_eq(|_|"test_bit_combinations 1 -1", combs.map(to_string_bits(8)).to_string, "[]");;

    let combs = bit_combinations(1, 0).to_array;
    assert_eq(|_|"test_bit_combinations 1 0", combs.map(to_string_bits(8)).to_string, "[00000000]");;

    let combs = bit_combinations(1, 1).to_array;
    assert_eq(|_|"test_bit_combinations 1 1", combs.map(to_string_bits(8)).to_string, "[00000001]");;

    let combs = bit_combinations(1, 2).to_array;
    assert_eq(|_|"test_bit_combinations 1 2", combs.map(to_string_bits(8)).to_string, "[]");;    

    let combs = bit_combinations(2, 0).to_array;
    assert_eq(|_|"test_bit_combinations 2 0", combs.map(to_string_bits(8)).to_string, "[00000000]");;

    let combs = bit_combinations(2, 1).to_array;
    assert_eq(|_|"test_bit_combinations 2 1", combs.map(to_string_bits(8)).to_string, "[00000001, 00000010]");;

    let combs = bit_combinations(2, 2).to_array;
    assert_eq(|_|"test_bit_combinations 2 2", combs.map(to_string_bits(8)).to_string, "[00000011]");;

    let combs = bit_combinations(4, 2).to_array;
    assert_eq(|_|"test_bit_combinations 4 2", combs.map(to_string_bits(8)).to_string, "[00000011, 00000101, 00000110, 00001001, 00001010, 00001100]");;

    let combs = bit_combinations(62, 0).to_array;
    assert_eq(|_|"test_bit_combinations 62 0", combs.get_size, 1);;

    let combs = bit_combinations(62, 1).to_array;
    assert_eq(|_|"test_bit_combinations 62 1", combs.get_size, 62);;

    let combs = bit_combinations(62, 2).to_array;
    assert_eq(|_|"test_bit_combinations 62 2", combs.get_size, 62 * 61 / 2);;

    let combs = bit_combinations(62, 60).to_array;
    assert_eq(|_|"test_bit_combinations 62 60", combs.get_size, 62 * 61 / 2);;

    let combs = bit_combinations(62, 61).to_array;
    assert_eq(|_|"test_bit_combinations 62 61", combs.get_size, 62);;

    let combs = bit_combinations(62, 62).to_array;
    assert_eq(|_|"test_bit_combinations 62 62", combs.get_size, 1);;

    pure()
);

test_bit_subsets : IO () = (
    let subs = bit_subsets(0).to_array;
    assert_eq(|_|"test_bit_subsets 0", subs.map(to_string_bits(8)).to_string, "[00000000]");;

    let subs = bit_subsets(1).to_array;
    assert_eq(|_|"test_bit_subsets 1", subs.map(to_string_bits(8)).to_string, "[00000001, 00000000]");;

    let subs = bit_subsets(2).to_array;
    assert_eq(|_|"test_bit_subsets 2", subs.map(to_string_bits(8)).to_string, "[00000010, 00000000]");;

    let subs = bit_subsets(3).to_array;
    assert_eq(|_|"test_bit_subsets 3", subs.map(to_string_bits(8)).to_string, "[00000011, 00000010, 00000001, 00000000]");;

    let subs = bit_subsets(5).to_array;
    assert_eq(|_|"test_bit_subsets 5", subs.map(to_string_bits(8)).to_string, "[00000101, 00000100, 00000001, 00000000]");;

    let subs = bit_subsets(15).to_array;
    assert_eq(|_|"test_bit_subsets 15", subs.map(to_string_bits(8)).to_string, "[00001111, 00001110, 00001101, 00001100, 00001011, 00001010, 00001001, 00001000, 00000111, 00000110, 00000101, 00000100, 00000011, 00000010, 00000001, 00000000]");;

    let subs = bit_subsets(0b101010).to_array;
    assert_eq(|_|"test_bit_subsets 0b101010", subs.map(to_string_bits(8)).to_string, "[00101010, 00101000, 00100010, 00100000, 00001010, 00001000, 00000010, 00000000]");;

    let subs = bit_subsets(1.shift_left(62) + 1).to_array;
    assert_eq(|_|"test_bit_subsets 1.shift_left(62) + 1", subs, [4611686018427387905, 4611686018427387904, 1, 0]);;

    pure()
);

test_bit_operations : IO () = (
    let x = 0.bit_set(2);
    assert_eq(|_|"test_bit_operations 1", to_string_bits(8, x), "00000100");;

    let x = x.bit_clear(2);
    assert_eq(|_|"test_bit_operations 2", to_string_bits(8, x), "00000000");;

    let x = x.bit_flip(0);
    assert_eq(|_|"test_bit_operations 3", to_string_bits(8, x), "00000001");;

    assert_eq(|_|"test_bit_operations 4", x.bit_check(0), true);;

    pure()
);

test_popcount : IO () = (
    assert_eq(|_|"test_popcount I64", 0b1111010011100111101110000111101000111111000001111101111100001000.popcount, 37);;
    assert_eq(|_|"test_popcount U64", 0b1111010011100111101110000111101000111111000001111101111100001000_U64.popcount, 37);;

    assert_eq(|_|"test_popcount I32", 0b11101001110011110111000011110100_I32.popcount, 19);;
    assert_eq(|_|"test_popcount U32", 0b11101001110011110111000011110100_U32.popcount, 19);;

    pure()
);
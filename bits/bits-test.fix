module CPLib.Bits.Test;

import CPLib.Bits::{
    bit_check, bit_clear, bit_combinations, bit_flip, bit_set, bit_subsets, to_string_bits, 
    Bits::popcount
};
import Std::{
    IO, Array::get_size, Debug::assert_eq, Functor::map, I64::shift_left, Iterator::to_array, 
    Monad::pure, ToString::to_string
};

test : IO () = (
    test_bit_combinations;;
    test_bit_subsets;;
    test_bit_operations;;
    test_popcount;;
    test_to_string_bits;;
    test_small_types_popcount;;
    pure()
);

test_bit_combinations : IO () = (
    let combs = bit_combinations(0, -1).to_array;
    assert_eq(|_|"test_bit_combinations 0 -1", combs.map(to_string_bits(8)).to_string, "[]");;

    let combs = bit_combinations(0, 0).to_array;
    assert_eq(|_|"test_bit_combinations 0 0", combs.map(to_string_bits(8)).to_string, "[00000000]");;

    let combs = bit_combinations(0, 1).to_array;
    assert_eq(|_|"test_bit_combinations 0 1", combs.map(to_string_bits(8)).to_string, "[]");;

    let combs = bit_combinations(1, -1).to_array;
    assert_eq(|_|"test_bit_combinations 1 -1", combs.map(to_string_bits(8)).to_string, "[]");;

    let combs = bit_combinations(1, 0).to_array;
    assert_eq(|_|"test_bit_combinations 1 0", combs.map(to_string_bits(8)).to_string, "[00000000]");;

    let combs = bit_combinations(1, 1).to_array;
    assert_eq(|_|"test_bit_combinations 1 1", combs.map(to_string_bits(8)).to_string, "[00000001]");;

    let combs = bit_combinations(1, 2).to_array;
    assert_eq(|_|"test_bit_combinations 1 2", combs.map(to_string_bits(8)).to_string, "[]");;    

    let combs = bit_combinations(2, 0).to_array;
    assert_eq(|_|"test_bit_combinations 2 0", combs.map(to_string_bits(8)).to_string, "[00000000]");;

    let combs = bit_combinations(2, 1).to_array;
    assert_eq(|_|"test_bit_combinations 2 1", combs.map(to_string_bits(8)).to_string, "[00000001, 00000010]");;

    let combs = bit_combinations(2, 2).to_array;
    assert_eq(|_|"test_bit_combinations 2 2", combs.map(to_string_bits(8)).to_string, "[00000011]");;

    let combs = bit_combinations(4, 2).to_array;
    assert_eq(|_|"test_bit_combinations 4 2", combs.map(to_string_bits(8)).to_string, "[00000011, 00000101, 00000110, 00001001, 00001010, 00001100]");;

    let combs = bit_combinations(62, 0).to_array;
    assert_eq(|_|"test_bit_combinations 62 0", combs.get_size, 1);;

    let combs = bit_combinations(62, 1).to_array;
    assert_eq(|_|"test_bit_combinations 62 1", combs.get_size, 62);;

    let combs = bit_combinations(62, 2).to_array;
    assert_eq(|_|"test_bit_combinations 62 2", combs.get_size, 62 * 61 / 2);;

    let combs = bit_combinations(62, 60).to_array;
    assert_eq(|_|"test_bit_combinations 62 60", combs.get_size, 62 * 61 / 2);;

    let combs = bit_combinations(62, 61).to_array;
    assert_eq(|_|"test_bit_combinations 62 61", combs.get_size, 62);;

    let combs = bit_combinations(62, 62).to_array;
    assert_eq(|_|"test_bit_combinations 62 62", combs.get_size, 1);;

    pure()
);

test_bit_subsets : IO () = (
    let subs = bit_subsets(0).to_array;
    assert_eq(|_|"test_bit_subsets 0", subs.map(to_string_bits(8)).to_string, "[00000000]");;

    let subs = bit_subsets(1).to_array;
    assert_eq(|_|"test_bit_subsets 1", subs.map(to_string_bits(8)).to_string, "[00000001, 00000000]");;

    let subs = bit_subsets(2).to_array;
    assert_eq(|_|"test_bit_subsets 2", subs.map(to_string_bits(8)).to_string, "[00000010, 00000000]");;

    let subs = bit_subsets(3).to_array;
    assert_eq(|_|"test_bit_subsets 3", subs.map(to_string_bits(8)).to_string, "[00000011, 00000010, 00000001, 00000000]");;

    let subs = bit_subsets(5).to_array;
    assert_eq(|_|"test_bit_subsets 5", subs.map(to_string_bits(8)).to_string, "[00000101, 00000100, 00000001, 00000000]");;

    let subs = bit_subsets(15).to_array;
    assert_eq(|_|"test_bit_subsets 15", subs.map(to_string_bits(8)).to_string, "[00001111, 00001110, 00001101, 00001100, 00001011, 00001010, 00001001, 00001000, 00000111, 00000110, 00000101, 00000100, 00000011, 00000010, 00000001, 00000000]");;

    let subs = bit_subsets(0b101010).to_array;
    assert_eq(|_|"test_bit_subsets 0b101010", subs.map(to_string_bits(8)).to_string, "[00101010, 00101000, 00100010, 00100000, 00001010, 00001000, 00000010, 00000000]");;

    let subs = bit_subsets(1.shift_left(62) + 1).to_array;
    assert_eq(|_|"test_bit_subsets 1.shift_left(62) + 1", subs, [4611686018427387905, 4611686018427387904, 1, 0]);;

    pure()
);

test_bit_operations : IO () = (
    let x = 0.bit_set(2);
    assert_eq(|_|"test_bit_operations 1", to_string_bits(8, x), "00000100");;

    let x = x.bit_clear(2);
    assert_eq(|_|"test_bit_operations 2", to_string_bits(8, x), "00000000");;

    let x = x.bit_flip(0);
    assert_eq(|_|"test_bit_operations 3", to_string_bits(8, x), "00000001");;

    assert_eq(|_|"test_bit_operations 4", x.bit_check(0), true);;

    pure()
);

test_popcount : IO () = (
    assert_eq(|_|"test_popcount I64", 0b1111010011100111101110000111101000111111000001111101111100001000.popcount, 37);;
    assert_eq(|_|"test_popcount U64", 0b1111010011100111101110000111101000111111000001111101111100001000_U64.popcount, 37);;

    assert_eq(|_|"test_popcount I32", 0b11101001110011110111000011110100_I32.popcount, 19);;
    assert_eq(|_|"test_popcount U32", 0b11101001110011110111000011110100_U32.popcount, 19);;

    pure()
);

// I32, I16, I8 などの小さい型に対する to_string_bits のテスト
// 特に符号付き整数の負の値の2の補数表現に注意
test_to_string_bits : IO () = (
    // I32 tests
    assert_eq(|_|"to_string_bits I32 positive", to_string_bits(32, 0b1010_I32), "00000000000000000000000000001010");;
    assert_eq(|_|"to_string_bits I32 zero", to_string_bits(32, 0_I32), "00000000000000000000000000000000");;
    // -1 は全ビット1 (2の補数表現)
    assert_eq(|_|"to_string_bits I32 -1", to_string_bits(32, -1_I32), "11111111111111111111111111111111");;
    // -2 は 11111111111111111111111111111110
    assert_eq(|_|"to_string_bits I32 -2", to_string_bits(32, -2_I32), "11111111111111111111111111111110");;

    // U32 tests
    assert_eq(|_|"to_string_bits U32", to_string_bits(32, 0b1010_U32), "00000000000000000000000000001010");;
    assert_eq(|_|"to_string_bits U32 max", to_string_bits(32, 4294967295_U32), "11111111111111111111111111111111");;

    // I16 tests
    assert_eq(|_|"to_string_bits I16 positive", to_string_bits(16, 0b1010_I16), "0000000000001010");;
    assert_eq(|_|"to_string_bits I16 zero", to_string_bits(16, 0_I16), "0000000000000000");;
    // -1 は全ビット1 (2の補数表現)
    assert_eq(|_|"to_string_bits I16 -1", to_string_bits(16, -1_I16), "1111111111111111");;
    // -2 は 1111111111111110
    assert_eq(|_|"to_string_bits I16 -2", to_string_bits(16, -2_I16), "1111111111111110");;
    // -128 は 1111111110000000
    assert_eq(|_|"to_string_bits I16 -128", to_string_bits(16, -128_I16), "1111111110000000");;

    // U16 tests
    assert_eq(|_|"to_string_bits U16", to_string_bits(16, 0b1010_U16), "0000000000001010");;
    assert_eq(|_|"to_string_bits U16 max", to_string_bits(16, 65535_U16), "1111111111111111");;

    // I8 tests
    assert_eq(|_|"to_string_bits I8 positive", to_string_bits(8, 0b1010_I8), "00001010");;
    assert_eq(|_|"to_string_bits I8 zero", to_string_bits(8, 0_I8), "00000000");;
    // -1 は全ビット1 (2の補数表現)
    assert_eq(|_|"to_string_bits I8 -1", to_string_bits(8, -1_I8), "11111111");;
    // -2 は 11111110
    assert_eq(|_|"to_string_bits I8 -2", to_string_bits(8, -2_I8), "11111110");;
    // -128 は 10000000 (I8の最小値)
    assert_eq(|_|"to_string_bits I8 -128", to_string_bits(8, -128_I8), "10000000");;
    // 127 は 01111111 (I8の最大値)
    assert_eq(|_|"to_string_bits I8 127", to_string_bits(8, 127_I8), "01111111");;

    // U8 tests
    assert_eq(|_|"to_string_bits U8", to_string_bits(8, 0b1010_U8), "00001010");;
    assert_eq(|_|"to_string_bits U8 max", to_string_bits(8, 255_U8), "11111111");;

    pure()
);

// I16, I8 などの小さい型に対する popcount のテスト
// 特に符号付き整数の負の値の振る舞いに注意
test_small_types_popcount : IO () = (
    // I16 tests
    assert_eq(|_|"popcount I16 positive", 0b1010_I16.popcount, 2);;
    assert_eq(|_|"popcount I16 zero", 0_I16.popcount, 0);;
    // -1 は全ビット1 なので popcount は 16
    assert_eq(|_|"popcount I16 -1", (-1_I16).popcount, 16);;
    // -2 は 1111111111111110 なので popcount は 15
    assert_eq(|_|"popcount I16 -2", (-2_I16).popcount, 15);;
    // -128 は 1111111110000000 なので popcount は 9
    assert_eq(|_|"popcount I16 -128", (-128_I16).popcount, 9);;

    // U16 tests
    assert_eq(|_|"popcount U16", 0b1010_U16.popcount, 2);;
    assert_eq(|_|"popcount U16 max", 65535_U16.popcount, 16);;

    // I8 tests
    assert_eq(|_|"popcount I8 positive", 0b1010_I8.popcount, 2);;
    assert_eq(|_|"popcount I8 zero", 0_I8.popcount, 0);;
    // -1 は全ビット1 なので popcount は 8
    assert_eq(|_|"popcount I8 -1", (-1_I8).popcount, 8);;
    // -2 は 11111110 なので popcount は 7
    assert_eq(|_|"popcount I8 -2", (-2_I8).popcount, 7);;
    // -128 は 10000000 なので popcount は 1
    assert_eq(|_|"popcount I8 -128", (-128_I8).popcount, 1);;
    // 127 は 01111111 なので popcount は 7
    assert_eq(|_|"popcount I8 127", 127_I8.popcount, 7);;

    // U8 tests
    assert_eq(|_|"popcount U8", 0b1010_U8.popcount, 2);;
    assert_eq(|_|"popcount U8 max", 255_U8.popcount, 8);;

    pure()
);